# -*- coding: utf-8 -*-
"""
Created on Tue Jan 28 13:19:24 2020

@author: Benda Robert
"""

"""
Objectives of this code : 

--> make the calculations of multipoles moments (summarizing the QM density of a given molecule) more modular :

- liberty in the choice of the method : DMA (Stone), BS-ISA (Misquitta et al.), etc.-

  Example : multipoles moments of elementary charge distributions computed with respect 
            to their natural expansion center and then redistributed to (e.g. one, or a few) nearest 
            sites (the chosen option being encoded in the integer 'index-philosophy' in the code)
  vs. 
           apportion the density in real-space, between sites (e.g. through Voronoi-like cells), 
           cf. e.g. BS-ISA method of Stone DMA/Switch 4 option (Stone, JCTC 1, 1128 (2005))]
  
- clarification and liberty in the choice of the multipole redistribution method 
  (from all natural expansion centers to the final retained centers, e.g. only nuclei 
  positions, or to all nuclei positions + bond centers, etc.)
  
  This would also make benchmark calculations easier (comparison of the performance of the multipole expansion
  keeping all natural expansion centers [tractable for small molecules], vs. of the multipole expansion redistributed
  on nuclei sites only, etc.) [in the spirit of the original paper Vigné-Maeder et al., JCP 88(8), 4934 (1988)]
  
  - choice of the order up to which multipoles are calculated (as in Stone DMA code, but adding the possibility 
    to impose different orders on different expansion sites, via the input user-provided 'l_max' table -- l_max[i] : multipole moment maximum order for site i)

--> Collaborative idea (plateform) : it should be easy for everyone to include / code its own version of multipole
    version (while keeping a standard output format, compatible with AMOEBA [i.e. multipole moments only on nuclei sites] ?).

--> The same entries as Stone's GDMA program must be supported (SCF density matrix, or density matrix from wave-function theory)

--> Output format compatible with Tinker/AMOEBA (for the case of multipoles assigned to nuclei only) 
    in particular with 'poledit' Tinker executable to convert spherical multipole moments into cartesian multipole moments.

Remarks :
    
    - information extracted from .log Gaussian file using cclib already implemented parsers 
      cf. 'extraction_QM_info.py' code => should be easy to generalize to other QM programs output
      given the modularity of cclib parsers (already implemented to parse outputs of many QM softwares)
    
Long-term ideas :
    
    - benchmark calculations (quality of multipoles depending on the different
      redistribution strategies / on the sites chosen to redistributed the multipoles)
    
    - interface this code with the MULFIT program ? (February 1998, G. G. Ferenczy, C. A. Reynolds and P. J. Winn,
      modified by A. J. Stone, 2006–2014) 
      MULFIT evaluates electrostatic potentials generated by distributions of multipole moments, e.g.
      DMA distributed multipoles => can be provided by the output of this code.
    
References :
    
    - A.J. Stone. Distributed multipole analysis, or how to describe a molecular charge distribution. 
    Chemical Physics Letters, 83(2):233–239, oct 1981
    
    - A.J. Stone and M. Alderton. Distributed multipole analysis. Molecular Physics, 56(5):1047–1064, dec 1985.
    
    - Fabienne Vigné-Maeder and Pierre Claverie. The exact multicenter multipolar part of a molecular charge distribution and
    its simplified representations. The Journal of Chemical Physics, 88(8):4934–4948, apr 1988.
"""

import numpy as np
import time
import math

import scipy.spatial.distance
from itertools import chain 


from extraction_QM_info import import_nb_primitive_shells
from extraction_QM_info import import_nb_contracted_shells
from extraction_QM_info import computes_nb_contracted_GTOs 
from extraction_QM_info import computes_nb_primitive_GTOs  
from extraction_QM_info import import_basis_set_exponents_primitive_GTOs
from extraction_QM_info import import_position_nuclei_associated_basis_function_pGTO 
from extraction_QM_info import import_density_matrix_contracted_GTOs
from extraction_QM_info import computes_angular_momentum_numbers_primitive_GTOs
from extraction_QM_info import compute_correspondence_index_contracted_GTOs_primitive_GTOs
from extraction_QM_info import compute_correspondence_index_primitive_GTOs_contracted_GTOs
from extraction_QM_info import import_correspondence_pGTOs_atom_index
from extraction_QM_info import import_contraction_scheme_matrix_pSHELLS_to_cSHELLS
from extraction_QM_info import correspondence_index_contracted_GTOs_contracted_shells
from extraction_QM_info import correspondence_index_primitive_GTOs_primitive_shells
from extraction_QM_info import compute_scalar_product_two_contracted_GTOs
from extraction_QM_info import compute_density_matrix_coefficient_pGTOs
from extraction_QM_info import compute_scalar_product_two_primitive_GTOs
from extraction_QM_info import compute_normalization_coefficient_primitive_GTO
#from extraction_QM_info import *

from auxiliary_functions import conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_D_shells
from auxiliary_functions import conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_F_shells
from auxiliary_functions import conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_D_shells_cartesian_F_shells
from auxiliary_functions import conversion_spherical_harmonics_cartesian_homogeneous_polynoms
from auxiliary_functions import computes_coefficient_solid_harmonic_l_m_list_format
from auxiliary_functions import coordinates_natural_center
from auxiliary_functions import l_max
from auxiliary_functions import boolean_final_expansion_site_is_atom
from auxiliary_functions import coordinates_final_expansion_centers
from auxiliary_functions import number_final_expansion_centers
from auxiliary_functions import compute_position_closest_final_site
from auxiliary_functions import gaussian_polynom_integral_all_R
from auxiliary_functions import coeff_W_binomial_expansion_polynoms
from auxiliary_functions import overlap_center_is_DMA_final_expansion_site
from auxiliary_functions import conversion_quadrupole_tensor_spherical_to_cartesian


#from auxiliary_functions import *

################################################
#GLOBAL VARIABLES :
#Distance tolerance threshold 
epsilon=1e-8
#Tolerance threshold on the multipole redistribution weight from P_{alpha,beta} to S
#(below this threshold, nothing is transfered from P_{alpha,beta} to S)
epsilon_weight=1e-5

############################
#CONVERSION CONSTANTS :
#1 Bohr in Angstroms
conversion_bohr_angstrom=0.529177209
################################################

###############################################################
###############################################################
##TO DO LIST

## - Define a Class 'Multipoles' (general object / format for multipoles) and a Class 'Multipoles_AMOEBA' ? 
#(for the multipole formats compatible with AMOEBA)

#  - get inspired from 'class Population(Method)' in population.py (cclib) ?

## - extract 'information_QM_calculation' from .fchk Gaussian file (or post-HF file) : 
##   use cclib functions (cf. "extraction_QM_info.py").

## - Code a function to interface main function with user input : 
#    user_extra_final_sites, index_philosophy, redistribution_strategy, l_max

###################################################################
#Import info from QM output file (e.g. (..).fchk ? => seems not supported by cclib)
#cclib support output Gaussian .log file as input
#Convert .fchk file into another format using Open Babel ?
#Use  ccget and possible associated imported attributes from a (...).log file or (...).fchk file


##################################################################################################################
##################################################################################################################
##################################################################################################################
##MAIN FUNCTIONS

    
    
###########################################################################################
###########################################################################################
#Methods useful for Stone's DMA multipoles (basis set [reciprocal space] point of view)
#Distributed Multipole Analysis

##############################################################
##MAIN FUNCTION N°1
###################
# Computes the multipole moments (Q_{l,m}^{alpha,beta})_{P_{alpha,beta}} at natural expansion centers
#FOR TWO PRIMITIVE GTOs (Gaussian Type Orbitals) \chi_{alpha}(.) and \chi_{beta}(.) centered at two points 'R_alpha' and 'R_beta'
#(generally position of nuclei)
# P_{alpha,beta} is the center of the elementary charge distribution ("alpha" and "beta" span the basis function indexes)
# chi*_{alpha}(.)*chi_{beta}(.) (GTO if chi_{alpha}(.) and chi_{beta}(.) contributing to the whole density)
#(l,m) are respectively the first and second angular momentum numbers (cf. spherical harmonics)
#Informations about QM basis functions used (exponents / contraction coefficients)
# + informations dealing with spherical harmonics (representation in cartesian coordinates)
#Remark : coefficient of the density matrix  (D_{alpha,beta}) : not used at this stage
#=> can be used in the final step (multipole redistribution at the final expansion sites,
#see function 'compute_DMA_multipole_moment_final_expansion_center_one_site()',
#to 'scale' the multipole moments computed by the function below.
#############################################################
#Can this function be parallelized over l, m, alpha and beta ?
#YES : see main function "compute_DMA_multipole_moment_final_expansion_center_all_sites_all_orders()"
#=> "compute_DMA_multipole_moment_natural_expansion_center()" is called by vectorization
###########################################################
#This function computes :
#integral (|u|^l*Y_(l,m)(\vec(u)/|u|)*(chi*_{alpha}^{pGTO}chi_{beta}^{pGTO})(\vec(u)+\vec(P)_{alpha,beta})) d \vec{u}
#(all the terms being centered at the origin by definition of the natural expansion center P_{alpha,beta})
#= C_{alpha,beta}* sum of terms integral( [x**(i_1(l_alpha,l_beta)+i_2(l_alpha,l_beta)+n_r(l,m))]
#                                           *[y**(j_1(l_alpha,l_beta)+j_2(l_alpha,l_beta)+m_r(l,m))]
#                                            *[z**(h_1(l_alpha,l_beta)+h_2(l_alpha,l_beta))]
#                                             *[exp(-(dzeta(alpha)+dzeta(beta))*(x**2+y**2+z**2))] dx dy dz)
#(or equivalently in spherical coordinates)
#######
## l_x(alpha,beta), l_y(alpha,beta), l_z(alpha,beta) : angular momentum expponents of the elementary charge distribution
# (chi*_{alpha}*chi_{beta})(\vec(r)+\vec(P)_{alpha,beta}) :
#[sum of homogeneous polynoms of degree [n_k(alpha,beta) + m_k(alpha,beta) + t_k(alpha,beta)] times a gaussian
#                                       (n_k <--> (l_x)_k, m_k <--> (l_y)_k , t_k <--> (l_z)_k) 
#where all these exponents are properties of the primitive GTOs
#######
# dzeta(alpha), dzeta(beta) : exponents of basis functions chi_{alpha}(.) and chi_{beta}(.) respectively : read from input QM file
#######
# n_r(l,m), m_r(l,m), t_r(l,m) : exponents of :
#|u|^l*Y_(l,m)(\vec(u)/|u|) = sum_r { (x**n_r(l,m))*(y**m_r(l,m))*(z**t_r(l,m)) }
##############################################################
#Q : Is there a library of precomputed (3D) integrals of [sums of] 
#(homogeneous) polynoms of degree l times gaussians ['centered' at 0] ? => 'libcint' ?
#=> OK : yes (analytical)
#############################################################
#"angular_momentum_numbers_primitive_GTOs" : obtained previously as 'angular_momentum_numbers_primitive_GTOs=computes_angular_momentum_numbers_primitive_GTOs(data)"
#############################################################
#IDEA : compute these multipole moments with respect to 'natural' (overlap) expansion
#centers once and for all (for a given molecule configuration, i.e. a set of nuclei positions)
#and store them ? (no need to recompute them every time for redistribution purposes i.e. for
#the final allocation/redistribution of multipole moments at the final expansion sites)
def compute_DMA_multipole_moment_natural_expansion_center_primitive_GTOs(l,m,alpha,beta,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,correspondence_basis_pGTOs_atom_index,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,position_nuclei_associated_basis_function_pGTO):
            
    R_alpha=position_nuclei_associated_basis_function_pGTO[alpha]
    R_beta=position_nuclei_associated_basis_function_pGTO[beta]
    
    #Vector joining the centers of the two primitive GTOs : usually in Angstroms
    #as atomic coordinates R_alpha, R_beta usually given in Angstroms
    vector_between_two_centers_alpha_beta=[R_alpha[i]-R_beta[i] for i in range(3)]
    
    #Normalizing constant N_alpha : such that the integral of \chi_{\alpha}^{pGTO}(.) squared is equal to 1
    #=>Result of 'compute_normalization_coefficient_primitive_GTO' in Bohr^{-3/2-l_alpha}
    normalizing_constant_alpha=compute_normalization_coefficient_primitive_GTO(alpha,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)
    
    #=>Result of 'compute_normalization_coefficient_primitive_GTO' in Bohr^{-3/2-l_beta}
    normalizing_constant_beta=compute_normalization_coefficient_primitive_GTO(beta,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)
    ##==> product normalizing_constant_alpha*normalizing_constant_beta in Bohr^{-3-l_alpha-l_beta}
    
    zeta_alpha=basis_set_exponents_primitive_GTOs[alpha]
    zeta_beta=basis_set_exponents_primitive_GTOs[beta]
     
    #Factor arising when making the product of two gaussians centered at two different points 
    #(= gaussian centered at a point in-between)
    #==> BEWARE of units (position of nuclei in Angstroms (cclib attribute 'atomcoords')
    #and 'zeta' exponents usaually provided in atomic units i.e. Bohr^{-2}
    K_alpha_beta=math.exp(-(conversion_bohr_angstrom**(-2))*(zeta_alpha*zeta_beta/(zeta_alpha+zeta_beta))*(np.linalg.norm(vector_between_two_centers_alpha_beta)**2))
    
    ##########################################################
    #Angular momentum numbers of the two primitive GTOs \chi_{\alpha}^{pGTO} and \chi_{\beta}^{pGTO} (Read from Gaussian file)
    ##Correspondence 'linear' index of pGTO alpha and couple (l_alpha,m_alpha) ? [as well as alpha (pGTO) --> zeta_exponent_p_GTO[alpha]]
    
    l_alpha=angular_momentum_numbers_primitive_GTOs[alpha][0]
    m_alpha=angular_momentum_numbers_primitive_GTOs[alpha][1]
    l_beta=angular_momentum_numbers_primitive_GTOs[beta][0]
    m_beta=angular_momentum_numbers_primitive_GTOs[beta][1]

    ##Information on the coefficients for conversion of r^l * Y_l^m(\vec{r}/|\vec{r}|)
    # "conversion_spherical_harmonics_cartesian_homogeneous_polynoms(l,m)" 
    #returns [p(l,m),[[n_1(l,m),m_1(l,m),t_1(l,m)],..[n_{p(l,m)}(l,m),m_{p(l,m)}(l,m),t_{p(l,m)}(l,m)]],[w_1^(l,m),w_2^(l,m),..,w_{p(l,m)}(l,m)]]
    ##ADD : 'if input==gaussian_type' / in case of Psi4 input : 'if input==psi4type'
    #=> code a function 'conversion_spherical_harmonics_cartesian_homogeneous_polynoms_with_Psi4_exception' 
    #implementing cartesian d- and f-type primitive shells (including respectively 6 and 10 primitive GTOs)
    if (boolean_cartesian_D_shells==True):
        
        if (boolean_cartesian_F_shells==False):
            
            if (l_alpha<=4):
                coeff_harmonics_cartesian_alpha=conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_D_shells(l_alpha,m_alpha)
            else:
                #Only spherical shells for l>=5 (G, H, etc. shells)
                coeff_harmonics_cartesian_alpha=computes_coefficient_solid_harmonic_l_m_list_format(l_alpha,m_alpha)
            
            if (l_beta<=4):
                coeff_harmonics_cartesian_beta=conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_D_shells(l_beta,m_beta)
            else:
                coeff_harmonics_cartesian_beta=computes_coefficient_solid_harmonic_l_m_list_format(l_beta,m_beta)
            
        elif (boolean_cartesian_F_shells==True):
            
            if (l_alpha<=4):
                coeff_harmonics_cartesian_alpha=conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_D_shells_cartesian_F_shells(l_alpha,m_alpha)
            else:
                coeff_harmonics_cartesian_alpha=computes_coefficient_solid_harmonic_l_m_list_format(l_alpha,m_alpha)
            
            if (l_beta<=4):
                coeff_harmonics_cartesian_beta=conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_D_shells_cartesian_F_shells(l_beta,m_beta)
            else:
                coeff_harmonics_cartesian_beta=computes_coefficient_solid_harmonic_l_m_list_format(l_beta,m_beta)
            
    
    elif (boolean_cartesian_D_shells==False):
        
        if (boolean_cartesian_F_shells==False):
            
            if (l_alpha<=4):
                coeff_harmonics_cartesian_alpha=conversion_spherical_harmonics_cartesian_homogeneous_polynoms(l_alpha,m_alpha)
            else:
                coeff_harmonics_cartesian_alpha=computes_coefficient_solid_harmonic_l_m_list_format(l_alpha,m_alpha)
            
            if (l_beta<=4):
                coeff_harmonics_cartesian_beta=conversion_spherical_harmonics_cartesian_homogeneous_polynoms(l_beta,m_beta)
            else:
                coeff_harmonics_cartesian_beta=computes_coefficient_solid_harmonic_l_m_list_format(l_beta,m_beta)
        
        elif (boolean_cartesian_F_shells==True):
            
            if (l_alpha<=4):
                coeff_harmonics_cartesian_alpha=conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_F_shells(l_alpha,m_alpha)
            else:
                coeff_harmonics_cartesian_alpha=computes_coefficient_solid_harmonic_l_m_list_format(l_alpha,m_alpha)
            if (l_beta<=4):
                coeff_harmonics_cartesian_beta=conversion_spherical_harmonics_cartesian_homogeneous_polynoms_cartesian_F_shells(l_beta,m_beta)
            else:
                coeff_harmonics_cartesian_beta=computes_coefficient_solid_harmonic_l_m_list_format(l_beta,m_beta)
                
    #Number p(l_alpha,m_alpha) of homogeneous cartesian polynoms of degree l_alpha entering the definition of \chi_{\alpha}(.)^{pGTO}:
    p_alpha=coeff_harmonics_cartesian_alpha[0]
    #Number p(l_beta,m_beta) of homogeneous cartesian polynoms of degree l_beta entering the definition of \chi_{\beta}(.)^{pGTO}:
    p_beta=coeff_harmonics_cartesian_beta[0]
    
    #[[n_1(l_alpha,m_alpha),m_1(l_alpha,m_alpha),t_1(l_alpha,m_alpha)],..[n_{p(l_alpha,m_alpha)}(l_alpha,m_alpha),m_{p(l_alpha,m_alpha)}(l_alpha,m_alpha),t_{p(l_alpha,m_alpha)}(l_alpha,m_alpha)]] :
    #tab_indexes_alpha[k][0] = n_k(l_alpha,m_alpha)
    #tab_indexes_alpha[k][1] = m_k(l_alpha,m_alpha)
    #tab_indexes_alpha[k][2] = t_k(l_alpha,m_alpha)
    tab_indexes_alpha=coeff_harmonics_cartesian_alpha[1]
    
    #Similarly :
    #tab_indexes_beta[q][0] = n_q(l_beta,m_beta)
    #tab_indexes_beta[q][1] = m_q(l_beta,m_beta)
    #tab_indexes_beta[q][2] = t_q(l_beta,m_beta)
    tab_indexes_beta=coeff_harmonics_cartesian_beta[1]
    
    #[w_1^(l_alpha,m_alpha),w_2^(l_alpha,m_alpha),..,w_{p(l_alpha,m_alpha)}(l_alpha,m_alpha)]
    #weights_spherical_harmonics_to_cartesian_alpha[k]= w_k^{l_alpha,m_alpha}
    weights_spherical_harmonics_to_cartesian_alpha=coeff_harmonics_cartesian_alpha[2]

    weights_spherical_harmonics_to_cartesian_beta=coeff_harmonics_cartesian_beta[2]

    #Expression of |r|^l * Y_l^m(\vec{r}/|r|) [pure spherical harmonics] as a polynom :
    
    if (l<=4):
        coeff_harmonics_cartesian_l_m=conversion_spherical_harmonics_cartesian_homogeneous_polynoms(l,m)
    else:
        #New function 05/08/20 :
        coeff_harmonics_cartesian_l_m=computes_coefficient_solid_harmonic_l_m_list_format(l,m)
    
    #print('l ='+str(l))
    #print('m ='+str(m))
    #print(conversion_spherical_harmonics_cartesian_homogeneous_polynoms(l,m))
    
    #Number p(l,m) of homogeneous cartesian polynoms of degree l entering the definition of |r|^l * Y_l^m(\vec{r}/|\vec{r}|) :
    p_l_m=coeff_harmonics_cartesian_l_m[0]
    
    #tab_indexes_l_m[r][0] = n_r(l,m)
    #tab_indexes_l_m[r][1] = m_r(l,m)
    #tab_indexes_l_m[r][2] = t_r(l,m)
    tab_indexes_l_m=coeff_harmonics_cartesian_l_m[1]
    
    weights_spherical_harmonics_to_cartesian_l_m=coeff_harmonics_cartesian_l_m[2]
    
    #############################################################################
    #Calculations of the multipole moments
    
    #Loops to calculate the multipole moments :
    multipole_moment_order_l_m_natural_expansion_center=0

    ##############################################################################
    #METHOD 1 :
    """
    #t_begin1=time.clock()

    for k in range(p_alpha):
        
        for q in range(p_beta):
            
            for r in range(p_l_m):
                
                #n_k(l_alpha,m_alpha)=tab_indexes_alpha[k][0]
                for i_1 in range(tab_indexes_alpha[k][0]+1):
                    
                    #n_q(l_beta,m_beta)=tab_indexes_beta[q][0]
                    for i_2 in range(tab_indexes_beta[q][0]+1):
                        
                        #m_k(l_alpha,m_alpha)=tab_indexes_alpha[k][1]
                        for j_1 in range(tab_indexes_alpha[k][1]+1):
                            
                            #m_q(l_beta,m_beta)=tab_indexes_beta[q][1]
                            for j_2 in range(tab_indexes_beta[q][1]+1):
                                
                                #t_k(l_alpha,m_alpha)=tab_indexes_alpha[k][2]
                                for h_1 in range(tab_indexes_alpha[k][2]+1):
                                    
                                    #t_q(l_beta,m_beta)=tab_indexes_beta[q][2]
                                    for h_2 in range(tab_indexes_beta[q][2]+1):
                                        
                                        product_integrals=gaussian_polynom_integral_all_R(i_1+i_2+tab_indexes_l_m[r][0])*gaussian_polynom_integral_all_R(j_1+j_2+tab_indexes_l_m[r][1])*gaussian_polynom_integral_all_R(h_1+h_2+tab_indexes_l_m[r][2])
                                        
                                        ##multipole_moment_order_l_m_natural_expansion_center+=product_integrals*(coeff_W_binomial_expansion_polynoms(tab_indexes_alpha[k],tab_indexes_beta[q],i_1,j_1,i_2,j_2,h_1,h_2,R_alpha,R_beta,zeta_alpha,zeta_beta)/(math.sqrt(zeta_alpha+zeta_beta))**(i_1+i_2+j_1+j_2+h_1+h_2))
                                        

                                        #Coefficients 'coeff_W_binomial_expansion_polynoms(...)' have the unit of a length at the power 
                                        #(l_{\alpha}+l_{\beta}-i_1-i_2-j_1-j_2-h_1-h_2) and 
                                        #1/sqrt(zeta_alpha+zeta_beta)**(i_1+i_2+j_1+j_2+h_1+h_2) 
                                        #of a length at the power (i_1+i_2+j_1+j_2+h_1+h_2)
                                        #==> compensation : the product of the two has the unit of
                                        # a length at the power (l_{\alpha}+l_{\beta})
                                        #'normalizing_constant_beta' and 'normalizing_constant_alpha' have the unit
                                        #of a length at a power (-3/2-l_{\beta}) and (-3/2-l_{\alpha}) respectively
                                        #==> need to be in the same length unit as 'coeff_W_binomial_expansion_polynoms(...)' coefficients
                                        #e.g. with lengths in Angstroms
                                        #==> result of the product of all terms (except (1/(math.sqrt(zeta_alpha+zeta_beta))**(3+l)))
                                        #has the unit of a length at the power -3
                                        #==> convert it back in Bohrs (if expressed in Angstroms)
                                        #if multiplied with non-modified term (1/(math.sqrt(zeta_alpha+zeta_beta))**(3+l))
                                        
                                        #=> Final unit of 'multipole_moment_order_l_m_natural_expansion_center' : in Bohr^l
                                        
                                        multipole_moment_order_l_m_natural_expansion_center+=(K_alpha_beta/(math.sqrt(zeta_alpha+zeta_beta))**(3+l))*normalizing_constant_alpha*normalizing_constant_beta*weights_spherical_harmonics_to_cartesian_alpha[k]*weights_spherical_harmonics_to_cartesian_beta[q]*weights_spherical_harmonics_to_cartesian_l_m[r]*product_integrals*coeff_W_binomial_expansion_polynoms(l_alpha,l_beta,tab_indexes_alpha[k],tab_indexes_beta[q],i_1,j_1,i_2,j_2,h_1,h_2,R_alpha,R_beta,zeta_alpha,zeta_beta)/(math.sqrt(zeta_alpha+zeta_beta)**(i_1+i_2+j_1+j_2+h_1+h_2))
                                        ##multipole_moment_order_l_m_natural_expansion_center+=(K_alpha_beta/(math.sqrt(zeta_alpha+zeta_beta))**(3+l))*normalizing_constant_alpha*normalizing_constant_beta*weights_spherical_harmonics_to_cartesian_alpha[k]*weights_spherical_harmonics_to_cartesian_beta[q]*weights_spherical_harmonics_to_cartesian_l_m[r]*product_integrals*(coeff_W_binomial_expansion_polynoms(tab_indexes_alpha[k],tab_indexes_beta[q],i_1,j_1,i_2,j_2,h_1,h_2,R_alpha,R_beta,zeta_alpha,zeta_beta)/(math.sqrt(zeta_alpha+zeta_beta))**(i_1+i_2+j_1+j_2+h_1+h_2))
   
    #t_end1=time.clock()
    #print('multipole_moment_order_l_m_natural_expansion_center method 1')
    #print(multipole_moment_order_l_m_natural_expansion_center)
    #print('Time method 1 : '+str(t_end1-t_begin1))
    #print(' ')
    """
    ##############################################################################
    
    ##############################################################################
    #METHOD 2 (vectorized): 
    
    #t_begin2=time.clock()
    
    ############
    #METHOD 2.1 (does not work because problem of 'flattening' of the nested lists to sum all elements)
    #contributions_multipole_moment_order_l_m_natural_expansion_center=[[[[[[[[[weights_spherical_harmonics_to_cartesian_alpha[k]*weights_spherical_harmonics_to_cartesian_beta[q]*weights_spherical_harmonics_to_cartesian_l_m[r]*gaussian_polynom_integral_all_R(i_1+i_2+tab_indexes_l_m[r][0])*gaussian_polynom_integral_all_R(j_1+j_2+tab_indexes_l_m[r][1])*gaussian_polynom_integral_all_R(h_1+h_2+tab_indexes_l_m[r][2])*(coeff_W_binomial_expansion_polynoms(l_alpha,l_beta,tab_indexes_alpha[k],tab_indexes_beta[q],i_1,j_1,i_2,j_2,h_1,h_2,R_alpha,R_beta,zeta_alpha,zeta_beta)/(math.sqrt(zeta_alpha+zeta_beta))**(i_1+i_2+j_1+j_2+h_1+h_2)) for h_2 in range(tab_indexes_beta[q][2]+1)] for h_1 in range(tab_indexes_alpha[k][2]+1)] for j_2 in range(tab_indexes_beta[q][1]+1)] for j_1 in range(tab_indexes_alpha[k][1]+1)] for i_2 in range(tab_indexes_beta[q][0]+1)] for i_1 in range(tab_indexes_alpha[k][0]+1)] for r in range(p_l_m)] for q in range(p_beta)] for k in range(p_alpha)] 
    
    #Use iter(contributions_multipole_moment_order_l_m_natural_expansion_center) ??
    #See https://stackoverflow.com/questions/50234355/apply-operation-and-list-to-nested-list
    
    #print(contributions_multipole_moment_order_l_m_natural_expansion_center)
    #print(np.sum(list(chain.from_iterable(contributions_multipole_moment_order_l_m_natural_expansion_center))))
    
    #print(contributions_multipole_moment_order_l_m_natural_expansion_center)
    #Ancienne tentative : np.sum() imbriqués :
    ###multipole_moment_order_l_m_natural_expansion_center=np.sum(np.sum(np.sum(np.sum(np.sum(np.sum(np.sum(contributions_multipole_moment_order_l_m_natural_expansion_center)))))))
    #Use only one time 'np.sum()' : does not work for a list of lists ??
    ############
    
    ############
    #METHOD 2.2 (slighty quicker than the naive, loop method)
    #The  computation time spared by this compact, 'vectorized' method seems very low (compared to method 1):
    #EXEMPLE : to compute all the  'multipole_moments_natural_centers' i.e. ({Q_(k,q)^{alpha,beta}}_{alpha,beta})_{k,q}
    #413 seconds for H2O and the basis cc-VQZ with the method 1 above (loop)
    #391 seconds for H2O and the same basis cc-VQZ with the method 2 below (vectorized and using np.sum())
    
    contributions_multipole_moment_order_l_m_natural_expansion_center=[weights_spherical_harmonics_to_cartesian_alpha[k]*weights_spherical_harmonics_to_cartesian_beta[q]*weights_spherical_harmonics_to_cartesian_l_m[r]*gaussian_polynom_integral_all_R(i_1+i_2+tab_indexes_l_m[r][0])*gaussian_polynom_integral_all_R(j_1+j_2+tab_indexes_l_m[r][1])*gaussian_polynom_integral_all_R(h_1+h_2+tab_indexes_l_m[r][2])*(coeff_W_binomial_expansion_polynoms(l_alpha,l_beta,tab_indexes_alpha[k],tab_indexes_beta[q],i_1,j_1,i_2,j_2,h_1,h_2,R_alpha,R_beta,zeta_alpha,zeta_beta)/(math.sqrt(zeta_alpha+zeta_beta))**(i_1+i_2+j_1+j_2+h_1+h_2)) for k in range(p_alpha)  for q in range(p_beta) for r in range(p_l_m) for h_2 in range(tab_indexes_beta[q][2]+1) for h_1 in range(tab_indexes_alpha[k][2]+1) for j_2 in range(tab_indexes_beta[q][1]+1) for j_1 in range(tab_indexes_alpha[k][1]+1) for i_2 in range(tab_indexes_beta[q][0]+1) for i_1 in range(tab_indexes_alpha[k][0]+1)] 

    multipole_moment_order_l_m_natural_expansion_center=np.sum(contributions_multipole_moment_order_l_m_natural_expansion_center)
    
    multipole_moment_order_l_m_natural_expansion_center*=normalizing_constant_alpha*normalizing_constant_beta
    multipole_moment_order_l_m_natural_expansion_center*=K_alpha_beta/(math.sqrt(zeta_alpha+zeta_beta))**(3+l)
    
    ############

    #t_end2=time.clock()
   
    #print('multipole_moment_order_l_m_natural_expansion_center method 2')
    #print(multipole_moment_order_l_m_natural_expansion_center)
    #print('Time method 2 : '+str(t_end2-t_begin2))
    ###########
     
    ##############################################################################
    
  
    return multipole_moment_order_l_m_natural_expansion_center
    
##########################################################################################################################   
    

 
##########################################################################################################################
##MAIN FUNCTION N°2
###################
#Computes (Q_(l,m))_{S} : multipole moment of order (l,m) at a given final expansion site S
#(x_S,y_S,z_S) denote the coordinates of one the final expansion center 
#(e.g. only nuclei position in Stone's DMA/ AMOEBA spirit)
#"multipole_moments_natural_centers" (already computed in the main function "compute_DMA_multipole_moment_final_expansion_center_all_sites_all_orders") 
#stores all the multipole moments [(Q_{k,q}^{alpha,beta})_{P_{alpha,beta}} | k, q, alpha, beta] 
# computed at the natural expansion centers (in a MATRIX FORM?)
    
#This function implements the redistribution of multipole moments referring to 'old' (natural) expansion centers
#to the 'new', finally retained expansion centers (e.g. nuclei positions)
#with different possible redistribution strategies (index indicated by 'redistribution_strategy' keyword).
#####################################################
##QUESTION : APPELER CETTE FONCTION POUR CHAQUE SITE S (comme actuellement), OU CALCULER DIRECTEMENT POUR TOUS
#LES SITES S RETENUS, l'ensemble des multipoles ? (WHAT IS THE MORE EFFICIENT ?)
#####################################################
#Implemented formula : 
#(Q_(l,m))_{S} = sum_{(alpha,beta) : P_{alpha,beta}=S} [(Q_{l,m}^{alpha,beta})_{P_{alpha,beta}}]
#                +sum_{(alpha',beta')} weight({alpha',beta'},S) * (-1)^(l+m) * [sum_{k=0..l} sum_{q=-k..k} K_{k,q}^{l,m} (Q_{k,q}^{alpha',beta'})_{P_{alpha',beta'}} ]
#where weight({alpha',beta'},S) is the fraction of the multipoles at center P_{alpha',beta'} redistributed
#at the final expansion center S (for instance in Stone DMA : =1 if and only if S is the final expansion site nearest to P_{alpha',beta'})
#and K_{k,q}^{l,m} is a numerical coefficient (depending on binomial coefficients and on the vector |P_{alpha',beta'}-S| : cf. multipoles redistribution formula [generalization of Newton binom to real spherical harmonics])
#"density_matrix_coefficient_pGTOs" : assumed computed before as a whole (for all pairs of indexes) before calling this function
#'atomnos' : attribute obtained previously (before calling this function) as 'data.atomnos'
def compute_DMA_multipole_moment_final_expansion_center_one_site(l,m,x_S,y_S,z_S,multipole_moments_natural_centers,density_matrix_coefficient_pGTOs,total_nb_primitive_GTOs,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,correspondence_basis_pGTOs_atom_index,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,atomnos,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,redistribution_strategy,positions_final_DMA_expansion_sites,logfile_DMA):

    ##HERE ONLY ONE center "S" treated 
    multipole_moment_order_l_m_final_expansion_center=0
    
    ##################################################################################################
    #First : IF the final expansion center S is one of the natural expansion centers P_{alpha,beta}
    #=> the multipole moments of the elementary charge distributions [chi*_{alpha}*chi_{beta}](.) centered on S (i.e. S=P_{alpha,beta} natural expansion center)
    #are first added (calculated thanks to the function computing multipole moments with respect to natural expansion enters)
    
    ##TO DO
    ###if (is_natural_expansion_center(x_S,y_S,z_S)==True)
    #and find the 'antécédents" {alpha,beta} of S (all tuples such that P_{alpha,beta}=S)
    #=> add directly the corresponding multipole moments to (Q_(l,m))_S ; avoiding the loop
    
    ###############################################################
    #NAIVE FORMULATION
    ##HOW TO AVOID THE LOOPS ??
   
    for alpha in range(total_nb_primitive_GTOs):
        
        ###################
        #Case alpha = beta :
        ##BEWARE !! If the overlap center P_{alpha,alpha} coincides with S : we add the multipole moments
        #contributions computed with respect to this point to the final multipole moment in S
        if (scipy.spatial.distance.pdist([coordinates_natural_center(alpha,alpha,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO),[x_S,y_S,z_S]])[0]< epsilon):  

            if (l_max(alpha,alpha,angular_momentum_numbers_primitive_GTOs)>=l):
            
                #'multipole_moments_natural_centers[alpha][0][l][m+l]' : order of magnitude of 1 (in [L]^l where [L] is the dimension of a length)
                multipole_moment_order_l_m_final_expansion_center+=density_matrix_coefficient_pGTOs[alpha][alpha]*multipole_moments_natural_centers[alpha][0][l][m+l]
                
        #Case alpha < beta
        #Factor "2" in the contribution due to the symmetry of (Q_{l,m}^{alpha,beta})_{P_{alpha,beta} in alpha <--> beta
        #and the symmetry of the pGTOs-density matrix
        for beta in range(alpha+1,total_nb_primitive_GTOs):
            
            #The multipole moments of the elementary charge distributions [chi*_{alpha}*chi_{beta}](.) centered on S (i.e. S=P_{alpha,beta} natural expansion center) are added
            #to the final multipole moment on S (at same order)
            if (scipy.spatial.distance.pdist([coordinates_natural_center(alpha,beta,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO),[x_S,y_S,z_S]])[0]< epsilon):  
                
                #Multipole moments with respect to natural expansion centers have already been calculated
                ##Renormalization of the multipole moment of order l,m by D_{alpha,beta}^{pGTO} (coefficient of the density matrix)
                #(i.e. multipole moments associated to elementary charge distribution D_{alpha,beta}^{pGTO}*\chi_{alpha}^{pGTO}*\chi_{beta}^{pGTO})
               
                
                ##BEWARE ! Size of 'multipole_moments_natural_centers[alpha][beta-alpha]={(Q_{l,m}^{alpha,beta})_{P_{alpha,beta}}_{l,m}
                #l=0...l_max(alpha,beta,angular_momentum_numbers_primitive_GTOs) / k = -l..l
                ##BEWARE : sometimes l_max(alpha,beta,angular_momentum_numbers_primitive_GTOs)=0 (ex. pour produits de 2 fonctions 's' de base)
                #=>multipole_moments_natural_centers[alpha][beta-alpha]=(Q_{l,m}^{alpha,beta})_{P_{alpha,beta} 
                #NOT DEFINED for l>=1 !
                #==> no contribution to (Q_{l,m})_{S} from moments (Q_{l,m}^{alpha,beta})_{P_{alpha,beta}} of order  l>=1 !!
                ##General case : multipoles (Q_{l,m}^{alpha_1,beta_1})_{P_{alpha,beta}
                #do contribute to (Q_{l,m})_{S} only up to order l=l_max(alpha,beta,angular_momentum_numbers_primitive_GTOs)
                if (l_max(alpha,beta,angular_momentum_numbers_primitive_GTOs)>=l):

                    #(n(r)=\sum_{COUPLES of pGTOs (alpha,beta) ; alpha <beta} D_{alpha, beta}^{pGTOs} \chi_{alpha}^{pGTOs}*(r) \chi_{beta}(r))
                    #Factor "2" (comming from the symmetry of D{k,l}^{cGTOs} :
                    #already taken into account in expression of 'D_{alpha, beta}^{pGTOs}'
                    multipole_moment_order_l_m_final_expansion_center+=density_matrix_coefficient_pGTOs[alpha][beta]*multipole_moments_natural_centers[alpha][beta-alpha][l][m+l]
                    
                ##By symmetry : the multipole moments (Q_{l,m}^{beta,alpha})_{P_{alpha,beta}} [also centered at P_{alpha,beta}=P_{beta,alpha}]
                #have also to be added (hence the factor 2)
                #density_matrix_coefficient_pGTOs[alpha][beta]=density_matrix_coefficient_pGTOs[beta][alpha]
    ###############################################################
    
    ###############################################################
    #Vectorized version (without loops) :
    #Contributions of the multipole moments from overlap centers ALREADY CENTERED AT S :
    """
    tab_contributions_ovelap_centers_S=[[density_matrix_coefficient_pGTOs[alpha][beta]*multipole_moments_natural_centers[alpha][beta-alpha][l][m+l] 
                                         if ( (scipy.spatial.distance.pdist([coordinates_natural_center(alpha,beta,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO),[x_S,y_S,z_S]])[0]< epsilon) and (l_max(alpha,beta,angular_momentum_numbers_primitive_GTOs)>=l) ) else 0 for beta in range(alpha,total_nb_primitive_GTOs)] for alpha in range(total_nb_primitive_GTOs)]
    
    multipole_moment_order_l_m_final_expansion_center+=np.sum(tab_contributions_ovelap_centers_S)
    """
    ##################################################################################################
    
    ##################################################################################################
    #Then : to the final multipole moment centered at point S, the contributions of the 
    #multipole moments at (e.g. neighboring) natural expansion centers (THAT ARE NOT FINAL EXPANSION SITES)
    #are added, following different (user-chosen) redistribution strategies (included in the 'weight')
    #BEWARE : DO NOT REDISTRIBUTE MULTIPOLE MOMENTS LOCATED AT THE EXPANSION CENTER P_{alpha,beta}=S 
    #(i.e. which is already a final DMA site : cf. particularly important in the case of Vigné-Maeder's redistribution strategy)
    
    #=> Check that the expansion centers from which we redistribute are different from S (otherwise : contributions already treated above)
    
    for alpha_1 in range(total_nb_primitive_GTOs):
        
        for beta_1 in range(alpha_1,total_nb_primitive_GTOs):
           
            #Checking that expansion centers P_{alpha_1,beta_1} 
            #from which we redistribute is 
            #DIFFERENT from the final expansion site S
            ##BEWARE : the overlap center P_{alpha_1,beta_1} can be ONE of the final
            #DMA expansion sites {S_k}, although it is not the currently examined 'S' expansion site.
            ##(see below the importance of this remark for the case 'redistribution_strategy=2')
            
            #Distance between the overlap center P_{alpha_1,beta_1} and S 
            #(here in Angstroms) larger than 'epsilon' i.e. they do not coincide
            if (scipy.spatial.distance.pdist([coordinates_natural_center(alpha_1,beta_1,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO),[x_S,y_S,z_S]])[0] > epsilon):  
                
                
                weight_redistrib=0
                
                ##########
                #IMPORTANT REMARK :
                ##IN THE CASE of Vigné-Maeder redistribution strategy ('redistribution_strategy'=2):
                #the redistribution weight = (1/|P_{alpha,beta}S|)/sum_k((1/|P_{alpha,beta}S_k|))
                #where |P_{alpha,beta}S_k| is the distance between 'natural' expansion center P_{alpha,beta}
                #and the final DMA expansion site S_k
                #==> if the overlap center P_{alpha,beta} coincides with one of the final DMA expansion sites
                #(e.g. an atom) 'S_i' => |P_{alpha,beta}S_i|=0 and this weight is no longer defined !
                #Cl : IN THE CASE of Vigné-Maeder redistribution strategy 
                #==> redistribute ONLY multipole moments NOT ALREADY CENTERED on a final expansion site
                #=> redistribution weight = 0 for an overlap center P_{alpha,beta}
                #already coinciding with one of the final DMA expansion sites
                if (redistribution_strategy==2):
                    
                    if (overlap_center_is_DMA_final_expansion_site(alpha_1,beta_1,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO,positions_final_DMA_expansion_sites)[0]==False):
                        #This overlap center does NOT coincide with any of the final DMA expansion sites
                        #==> we can compute the 'Vigné-Maeder redistribution weight' safely =) :
                        weight_redistrib=weight_redistribution_multipoles(alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,correspondence_basis_pGTOs_atom_index,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,redistribution_strategy,positions_final_DMA_expansion_sites)
                    
                    #Otherwise : this overlap center DOES coincide with one
                    #of the final DMA expansion sites => no need to readistribute
                    #the multipole moments centered at this point ==> weight_redistrib=0
                
                else:
                    #########
                    #Otherwise (e.g. Stone's redistribution strategy : everything reallocated to the 
                    #nearest neighbor final site) => regular calculation of the weight
                    #Calculation of weight({alpha',beta'},S) [redistribution weight / 'fraction'] 
                    #before the component of redistributed multipoles is actually computed (to spare computation time)
                    ##Independent of (l,m) ==> could be computed elsewhere and stored ??
                    #e.g. [[weight_redistribution_multipoles(alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,user_extra_final_sites,index_philosophy,redistribution_strategy,positions_final_DMA_expansion_sites) for beta in range(total_nb_primitive_GTOs)] for alpha in range(total_nb_primitive_GTOs)]
                    #for each final expansion site S
                    weight_redistrib=weight_redistribution_multipoles(alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,correspondence_basis_pGTOs_atom_index,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,redistribution_strategy,positions_final_DMA_expansion_sites)
                
                if (weight_redistrib>epsilon_weight):
                    
                    #########################################################
                    #USING REDISTRIBUTION FORMULA FOR COMPLEX MULTIPOLES 
                    redistributed_multipoles=0
                    
                    if (m>0):
                        
                        real_part_1=real_part_redistributed_complex_multipoles(l,-m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
                        
                        real_part_2=real_part_redistributed_complex_multipoles(l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)

                        redistributed_multipoles+=(real_part_1+((-1)**m)*real_part_2)/math.sqrt(2)
                       
                        
                    elif (m<0):
                        
                        imaginary_part_1=imaginary_part_redistributed_complex_multipoles(l,abs(m),alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
                        
                        imaginary_part_2=imaginary_part_redistributed_complex_multipoles(l,-abs(m),alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
                        
                        redistributed_multipoles+=(((-1)**m)*imaginary_part_1-imaginary_part_2)/math.sqrt(2)
                     
                    elif (m==0):
                            
                        redistributed_multipoles+= real_part_redistributed_complex_multipoles(l,0,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
                    
                    #########################################################
                
                    ################################
                    multipole_moment_order_l_m_final_expansion_center+=weight_redistrib*redistributed_multipoles
                    #############################
  
    
    #############################################################################################################
    #In the case of an expansion center coinciding with a nuclei A (e.g. the case for all DMA expansion sites in AMOEBA)
    #==> we substract (Q_{0,0})_S = (Q_{0,0})_A (multipole moment of order 0 of the ELECTRONIC density
    #i.e. total charge of the ELECTRONS has been calculated, but does not include nuclei charge)
    #to Z_A (the total positive charge at this nuclei) i.e. we correct the 'monopoles' by including the charges of the nuclei
    
    if (l==0):
        #Testing if the expansion center S is or not a nuclei :
        #And 'test_center_S_atom[1]' returns the index of the corresponding atom 
        #IF this expansion center coincides with a nuclei.
        test_center_S_atom=boolean_final_expansion_site_is_atom(x_S,y_S,z_S,atomic_coordinates)
    
        if (test_center_S_atom[0]==True):
            
            #In this case 'test_center_S_atom[1]' is the index of the atom 
            #which coincides with the final expansion site 'S'
            logfile_DMA.write('l = 0 : ')
            logfile_DMA.write('\n')
            logfile_DMA.write('Electronic charge found on atom '+str(test_center_S_atom[1]))
            logfile_DMA.write('\n')
            logfile_DMA.write(str(multipole_moment_order_l_m_final_expansion_center))
            logfile_DMA.write('\n')
            logfile_DMA.write('Nucleus charge on atom '+str(test_center_S_atom[1]))
            logfile_DMA.write('\n')
            logfile_DMA.write(str(atomnos[test_center_S_atom[1]]))
            logfile_DMA.write('\n')
            logfile_DMA.write("\n")
            multipole_moment_order_l_m_final_expansion_center=atomnos[test_center_S_atom[1]]-multipole_moment_order_l_m_final_expansion_center
    
        else:
            #Otherwise : if the DMA final expansion site 'S' is not an atom
            #=> the monopole counts the electronic density (i.e. in units of (-e))
            #==> change of sign necessary
            multipole_moment_order_l_m_final_expansion_center=-multipole_moment_order_l_m_final_expansion_center
    
    elif (l>=1):
        #=> The multipole moments counts the electronic density (i.e. in units of (-e))
        #==> change of sign is necessary :
        multipole_moment_order_l_m_final_expansion_center=-multipole_moment_order_l_m_final_expansion_center
    
    ###############################

    return multipole_moment_order_l_m_final_expansion_center
##########################################################################################################################
    

##################################################################################################################
##################################################################################################################
##################################################################################################################

    
##########################################################################################################################
##MAIN FUNCTION N°3 (and function used to launch the calculation of all the distributed multipoles at all sites)
#########################################################
#Computes the final multipole moments series on all sites
#'l_max_user' is a table (of size = to the number of final expansion sites) read from the user-specified input :
#l_max_user[i] is the multipole order at site i (e.g. = 2 (+1 as we use 'l in range(0,l_max_user[i])') for quadrupole)
###############
## (Still to do) Merge 'user_extra_final_sites,index_philosophy,redistribution_strategy,l_max_user' parameters
#into a same input file format
def compute_DMA_multipole_moment_final_expansion_center_all_sites_all_orders(QM_data,input_type,boolean_cartesian_D_shells,boolean_cartesian_F_shells,psi4_exception_P_GTOs_indexation_order,psi4_exception_D_GTOs_indexation_order,atomic_coordinates,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,redistribution_strategy,l_max_user,logfile_DMA,DMA_output_files_dir):
    
    t_begin=time.clock()


    ###################################
    
    ##############################################
    #Information printing
    
    if (redistribution_strategy==1):
        logfile_DMA.write('Stone redistribution_strategy')
    elif (redistribution_strategy==2):
        logfile_DMA.write('Vigné-Maeder redistribution strategy')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    if (boolean_all_atomic_sites):
        logfile_DMA.write('All atomic sites kept as final DMA expansion centers')
        logfile_DMA.write("\n")
    else:
        logfile_DMA.write('Not all atomic sites kept as final DMA expansion centers. Omitted atoms indexes are :')
        logfile_DMA.write(atomic_sites_to_omit)
        logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    if (index_philosophy==1):
        logfile_DMA.write('AMOEBA philosophy : only nuclei kept as final sites')

    elif (index_philosophy==2):
        logfile_DMA.write('Nuclei AND bond centers are kept as final DMA sites')

    elif (index_philosophy==3):
        logfile_DMA.write('Nuclei AND user-defined additional sites are kept as final DMA sites')
      
    elif (index_philosophy==4):
        logfile_DMA.write('User-defined sites are kept as final DMA sites')
      
    elif (index_philosophy==5):
        logfile_DMA.write('All overlap centers kep as final DMA expansion sites')
    
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    ##############################################
    
    ##############################################################################################
    #Useful informations are extracted from the QM output (stored in 'information_QM_calculation')
    #[extraction of relevant info from QM output file : done once and for all, 
    #before (distributed) multipole moments calculations]
    
    nb_contracted_shells=import_nb_contracted_shells(QM_data,input_type)[1]
    logfile_DMA.write('nb_contracted_shells= '+str(nb_contracted_shells))
    logfile_DMA.write("\n")
    if (input_type=='Psi4'):
        logfile_DMA.write("(SP shell counted as 2 (contracted) shells (S, P))")
    else:
        #Case of Gaussian, GAMESS:
        logfile_DMA.write("(SP shell counted as 1 (contracted) shell)")    
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    nb_primitive_shells=import_nb_primitive_shells(QM_data)[1]
    logfile_DMA.write('nb_primitive_shells = '+str(nb_primitive_shells))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    nb_contracted_GTOs=computes_nb_contracted_GTOs(QM_data,input_type,boolean_cartesian_D_shells,boolean_cartesian_F_shells)
    logfile_DMA.write('nb_contracted_GTOs = '+str(nb_contracted_GTOs))
    logfile_DMA.write("\n")
    logfile_DMA.write("(= nb of basis functions)")
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    nb_primitive_GTOs=computes_nb_primitive_GTOs(QM_data,input_type,boolean_cartesian_D_shells,boolean_cartesian_F_shells)
    total_nb_primitive_GTOs=nb_primitive_GTOs[1]
    logfile_DMA.write('total_nb_primitive_GTOs = '+str(total_nb_primitive_GTOs))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    logfile_DMA.write('boolean_cartesian_D_shells = '+str(boolean_cartesian_D_shells))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    logfile_DMA.write('boolean_cartesian_F_shells = '+str(boolean_cartesian_F_shells))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    logfile_DMA.write('psi4_exception_P_GTOs_indexation_order = '+str(psi4_exception_P_GTOs_indexation_order))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")

    logfile_DMA.write('psi4_exception_D_GTOs_indexation_order = '+str(psi4_exception_D_GTOs_indexation_order))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    #Basis set exponents of primitive GTOs functions (in Bohr^{-2} or Ang^{-2}) :
    #Use np.dot((1/(conversion_bohr_angstrom)**2),extraction_QM_info()) 
    #for conversion from Bohrs^{-2} to Angstrom^{-2}
    basis_set_exponents_primitive_GTOs=import_basis_set_exponents_primitive_GTOs(QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells)
    logfile_DMA.write('basis_set_exponents_primitive_GTOs :')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(basis_set_exponents_primitive_GTOs))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    #We pick up the last value of 'atomcoords' cclib attribute
    #in the case of a gemetry optimization (i.e. the optimized geometry)
    ###atomic_coordinates=QM_data.atomcoords[len(QM_data.atomcoords)-1]
    logfile_DMA.write('atomic_coordinates :')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(atomic_coordinates))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    nb_atoms=len(atomic_coordinates)
    
    #Number of atoms = len(atomic_coordinates)
    position_nuclei_associated_basis_function_pGTO=import_position_nuclei_associated_basis_function_pGTO(atomic_coordinates,nb_primitive_GTOs,len(atomic_coordinates),QM_data)
    logfile_DMA.write('position_nuclei_associated_basis_function_pGTO :')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(position_nuclei_associated_basis_function_pGTO))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")    
    ##BEWARE  : if UHF calculation => alpha and beta density matrices
    #=> summing multipole moments times alpha and beta density matrices coefficients
    #Conversion in e/Ang^3 ? (from e/bohr^3)
    #If conversion from e/Ang^3 TO e/bohr^3:
    ##density_matrix_coefficient_contracted_GTOs=np.dot((conversion_bohr_angstrom)**3,extraction_QM_info.import_density_matrix_contracted_GTOs(QM_data))
    density_matrix_coefficient_contracted_GTOs=import_density_matrix_contracted_GTOs(QM_data,logfile_DMA)
    #print('density_matrix_coefficient_contracted_GTOs')
    #print(density_matrix_coefficient_contracted_GTOs)
    #print(' ')
    
    angular_momentum_numbers_primitive_GTOs=computes_angular_momentum_numbers_primitive_GTOs(QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,input_type,psi4_exception_P_GTOs_indexation_order,psi4_exception_D_GTOs_indexation_order)
    logfile_DMA.write('angular_momentum_numbers_primitive_GTOs :')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(angular_momentum_numbers_primitive_GTOs))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    correspondence_index_contracted_GTOs_primitive_GTOs=compute_correspondence_index_contracted_GTOs_primitive_GTOs(QM_data,input_type,boolean_cartesian_D_shells,boolean_cartesian_F_shells)
    logfile_DMA.write('correspondence_index_contracted_GTOs_primitive_GTOs :')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(correspondence_index_contracted_GTOs_primitive_GTOs))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    correspondence_index_primitive_GTOs_contracted_GTOs=compute_correspondence_index_primitive_GTOs_contracted_GTOs(correspondence_index_contracted_GTOs_primitive_GTOs,total_nb_primitive_GTOs)
    logfile_DMA.write('correspondence_index_primitive_GTOs_contracted_GTOs :')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(correspondence_index_primitive_GTOs_contracted_GTOs))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    ############
    #VERIFICATION :
        
    #Information used by 'compute_scalar_product_two_primitive_GTOs()'
    #For each primitive GTO : gives the index of the atom on which it is centered
    correspondence_basis_pGTOs_atom_index=import_correspondence_pGTOs_atom_index(nb_primitive_GTOs,nb_atoms)
    
    #Contraction coefficients given in e/bohr^(3/2) (atomic units) by Gaussian output file
    contraction_coefficients_pSHELLS_to_cSHELLS=import_contraction_scheme_matrix_pSHELLS_to_cSHELLS(QM_data,input_type,nb_contracted_shells,input_type)
    logfile_DMA.write('contraction_coefficients_pSHELLS_to_cSHELLS')
    logfile_DMA.write("\n")
    logfile_DMA.write(str(contraction_coefficients_pSHELLS_to_cSHELLS))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")

    tab_correspondence_index_contracted_GTOs_contracted_shells=correspondence_index_contracted_GTOs_contracted_shells(QM_data,input_type,nb_contracted_GTOs,boolean_cartesian_D_shells,boolean_cartesian_F_shells)
    logfile_DMA.write('tab_correspondence_index_contracted_GTOs_contracted_shells :')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(tab_correspondence_index_contracted_GTOs_contracted_shells))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    tab_correspondence_index_primitive_GTOs_primitive_shells=correspondence_index_primitive_GTOs_primitive_shells(QM_data,input_type,total_nb_primitive_GTOs,boolean_cartesian_D_shells,boolean_cartesian_F_shells)
    logfile_DMA.write('tab_correspondence_index_primitive_GTOs_primitive_shells :')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(tab_correspondence_index_primitive_GTOs_primitive_shells))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    #Density matrix needed in the basis of PRIMITIVE GTOs for multipole moments calculations
    #TODO : adapt in the case of open shell systems (doubly + singly occupied orbitals)
    density_matrix_coefficient_pGTOs=compute_density_matrix_coefficient_pGTOs(QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,nb_primitive_GTOs,density_matrix_coefficient_contracted_GTOs,contraction_coefficients_pSHELLS_to_cSHELLS,tab_correspondence_index_contracted_GTOs_contracted_shells,tab_correspondence_index_primitive_GTOs_primitive_shells,correspondence_index_contracted_GTOs_primitive_GTOs,correspondence_index_primitive_GTOs_contracted_GTOs,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO,total_nb_primitive_GTOs,nb_contracted_GTOs,nb_primitive_shells,nb_contracted_shells,logfile_DMA)
    
    logfile_DMA.write('density_matrix_coefficient_pGTOs : ')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    logfile_DMA.write(str(density_matrix_coefficient_pGTOs))
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")

    #Gram matrix (nb_contracted_GTOs² scalar products) of contracted GTOs :    
    scalar_products_contracted_GTOs=[[compute_scalar_product_two_contracted_GTOs(i,j,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,nb_primitive_GTOs,correspondence_index_contracted_GTOs_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs,contraction_coefficients_pSHELLS_to_cSHELLS,tab_correspondence_index_contracted_GTOs_contracted_shells,tab_correspondence_index_primitive_GTOs_primitive_shells,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO) for j in range(nb_contracted_GTOs)] for i in range(nb_contracted_GTOs)]
    #*** Remark : this matrix of scalar product of contracted GTOs (=the basis functions
    #used in the quantum calculations) should EXACTLY coincide with 'aooverlaps' cclib attribute
    #available from the QM output file with cclib e.g. in Gaussian thanks to "iop(3/33=1)" keyword
    
    """
    for i in range(nb_contracted_GTOs):
        #print('scalar_products_contracted_GTOs['+str(i)+']')
        print(scalar_products_contracted_GTOs[i])
        print(' ')
    
    
    for i in range(nb_contracted_GTOs):
        print('density_matrix_coefficient_contracted_GTOs['+str(i)+']')
        print(density_matrix_coefficient_contracted_GTOs[0][i])
        print(' ')
    """
    #######
    #Checking idempotency of the density matrix computed by cclib :
    #density_matrix_square=np.dot(density_matrix_coefficient_contracted_GTOs[0],density_matrix_coefficient_contracted_GTOs[0])
    #print([[ (density_matrix_square[i][j]-density_matrix_coefficient_contracted_GTOs[0][i][j]) if (np.abs((density_matrix_square[i][j]-density_matrix_coefficient_contracted_GTOs[0][i][j]))>epsilon) else 0 for j in range(nb_contracted_GTOs)] for i in range(nb_contracted_GTOs)])
    
    ####################################
    #VERIFICATION total electronic charge recovered with the CONTRACTED density matrix expression of the density :
    #Q_tot (negative total charge ; total number of electrons) = 2* Tr(S^{cGTOs}*D^{cGTOs}) = 2 * sum_k [S*D]_kk
    #                                                                       = 2 * sum_k sum_i (S_ki * D_ik)  and S_ki= S_ik= <psi^{cGTO}_i|psi^{cGTO}_k>
    
    #print('Total number of electrons : Tr(S*D) : ')
    #print(np.trace(np.dot(scalar_products_contracted_GTOs,density_matrix_coefficient_contracted_GTOs[0])))
    
    #Other way to compute the trace :
    #Tr(S*D) = sum_{mu,nu} (S_{mu,nu} * D_{mu,nu})
    Q_tot=0
    
    for mu in range(nb_contracted_GTOs):
        
        for nu in range(nb_contracted_GTOs):
            
            #######
            #CASE 1 : closed-shell systems :
            #Sum over alpha and beta density matrices :
            for sigma in range(len(density_matrix_coefficient_contracted_GTOs)):
                
                Q_tot+=density_matrix_coefficient_contracted_GTOs[sigma][mu][nu]*scalar_products_contracted_GTOs[mu][nu]
            
            #######

            """
            #######
            #CASE 2 : open-shell systems :
            # FALSE FORMULA : TO BE CORRECTED (using cclib correct input, see :
            # https://github.com/cclib/cclib/issues/836 )
            #Total number of electrons = 2*Nd+Ns = Tr((Pd+Ps)*S) = Tr(Pd*S)+Tr(Ps*S)
            # P=Pd+Ps being the total density matrix
            Q_tot+=density_matrix_coefficient_contracted_GTOs[0][mu][nu]*scalar_products_contracted_GTOs[mu][nu]
            Q_tot+=0.5*density_matrix_coefficient_contracted_GTOs[1][mu][nu]*scalar_products_contracted_GTOs[mu][nu]
            #######
            """
    
    """
    ###########
    #Other equivalent method :
    for mu in range(nb_contracted_GTOs):

        for sigma in range(len(density_matrix_coefficient_contracted_GTOs)):
            #Using the fact that contracted GTOs (basis functions in the quantum calculation)
            #are normalized :
            Q_tot+=density_matrix_coefficient_contracted_GTOs[sigma][mu][mu]
            
        for nu in range(mu+1,nb_contracted_GTOs):
            
            for sigma in range(len(density_matrix_coefficient_contracted_GTOs)):
                #Factor "2" by symmetry of these terms for mu < nu and nu < mu  :
                Q_tot+=2*density_matrix_coefficient_contracted_GTOs[sigma][mu][nu]*scalar_products_contracted_GTOs[mu][nu]
    ###########
    """
    
    logfile_DMA.write('Total charge with D^{cGTOs} = Tr(S_c*D) = '+str(Q_tot))
    logfile_DMA.write("\n")
    logfile_DMA.write('(S_c = contracted GTOs overlap matrix)')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    
    #print(Q_tot)
    
    #####################################
    
    #Gram matrix (nb_primitive_GTOs² scalar products) of NORMALIZED primitive GTOs :    
    #(N_{alpha}*N_{beta}*<\chi_{alpha}^{pGTO} | \chi_{beta}^{pGTO}>  where \chi_{alpha}^{pGTO}(.) is a NON-normalized solid spherical harmonic times a gaussian)
    
    scalar_products_primitive_GTOs=[[compute_normalization_coefficient_primitive_GTO(alpha,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)*compute_normalization_coefficient_primitive_GTO(beta,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)*compute_scalar_product_two_primitive_GTOs(alpha,beta,boolean_cartesian_D_shells,boolean_cartesian_F_shells,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO) for beta in range(total_nb_primitive_GTOs)] for alpha in range(total_nb_primitive_GTOs)]
    
    
    ####################################
    #VERIFICATION total electronic charge recovered with the PRIMITIVE density matrix expression of the density :
    #Q_tot (negative total charge ; total number of electrons)
    #= 2* Tr(S^{pGTOs}*D^{pGTOs}) = 2 * sum_k [S*D]_kk
    #= 2 * sum_k sum_i (S_ki * D_ik)  and S_ki= S_ik= <psi^{pGTO}_i|psi^{pGTO}_k>
    
    Q_tot_bis=0
    for i in range(total_nb_primitive_GTOs): 
           
        #normalization_coeff_pGTO_i=extraction_QM_info.compute_normalization_coefficient_primitive_GTO(i,QM_data,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)

        for j in range(i,total_nb_primitive_GTOs):
            
            #normalization_coeff_pGTO_j=extraction_QM_info.compute_normalization_coefficient_primitive_GTO(j,QM_data,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)

            Q_tot_bis+=density_matrix_coefficient_pGTOs[i][j]*scalar_products_primitive_GTOs[i][j]
    
    logfile_DMA.write('Total charge with D^{pGTOs} = Tr(S_p*D) = '+str(Q_tot_bis))
    logfile_DMA.write("\n")
    logfile_DMA.write('(S_p = primitive GTOs overlap matrix)')
    logfile_DMA.write("\n")
    logfile_DMA.write("\n")
    #####################################
    #print('Total number of electrons : Tr(S^{pGTOs}*D^{pGTOs}) : ')
    #print(Q_tot_bis)
    
    
    ##############################################################################################
    #Multipole moments WITH RESPECT TO NATURAL EXPANSION CENTERS are first calculated :
    #=> DONE ONCE only (not for each new final expansion center !)
    
    #######################
    #=> PARALLELIZED over alpha and beta (indexes of QM basis functions) [vectorization]
    ##Construct a list of list of list of lists [all multipoles moments being computed with respect to the 
    #natural expansion center P_{alpha,beta}] :
    #[ [[[[Q_(0,0)^{alpha=0,beta=0}],[Q_(1,-1)^{alpha=0,beta=0},..,Q_(1,1)^{alpha=0,beta=0}],..,[Q_(l_max(alpha=0,beta=0),-l_max(alpha=0,beta=0))^{alpha=0,beta=0},..,Q_(l_max(alpha=0,beta=0),l_max(alpha=0,beta=0))^{alpha=0,beta=0}]]],
    #  [[Q_(0,0)^{alpha=0,beta=1}],[Q_(1,-1)^{alpha=0,beta=1},..,Q_(1,1)^{alpha=0,beta=1}],..,[Q_(l_max(alpha=0,beta=1),-l_max(alpha=0,beta=1))^{alpha=0,beta=1},..,Q_(l_max(alpha=0,beta=1),l_max(alpha=0,beta=1))^{alpha=0,beta=1}]],
    #  ...
    #  [[Q_(0,0)^{alpha=0,beta=1}],[Q_(1,-1)^{alpha=0,beta=N'},..,Q_(1,1)^{alpha=0,beta=N'}],..,[Q_(l_max(alpha=0,beta=N'),-l_max(alpha=0,beta=N'))^{alpha=0,beta=N'},..,Q_(l_max(alpha=0,beta=N'),l_max(alpha=0,beta=N'))^{alpha=0,beta=N'}]]],
    #  ....(same list of list (...) of list, for alpha =1)
    #  ....
    #  [[[[Q_(0,0)^{alpha=N',beta=N'}],[Q_(1,-1)^{alpha=N',beta=N'},..,Q_(1,1)^{alpha=N',beta=N'}],..,[Q_(l_max(alpha=N',beta=N'),-l_max(alpha=N',beta=N'))^{alpha=N',beta=N'},..,Q_(l_max(alpha=N',beta=N'),l_max(alpha=N',beta=N'))^{alpha=N',beta=N'}]]]]  ]
    #
    #Conclusion : (Q_(l,m)^{alpha,beta})_{P_{alpha,beta})=multipole_moments_natural_centers[alpha][beta][l][m+l] with these notations
    
    ##BEWARE : multipole moments below (with respect to NATURAL expansion centers) are computed up to maximal order (e.g. l_max=2 if product of s and d function, or or 2 p functions, or l_max=3 if product of p and d function, etc.)
    ##'l_max' must not be confused with 'l_max_user', which specifies the final maximal order (rank)
    # of the multipole moments at the final sites of the dsitributed analysis (e.g. all nuclei)
    ##Beware : 'q in range(-k,k) => only goes up to (k-1) !!
    
    t_begin_1=time.clock()

    ##'beta in range(alpha,nb_basis_functions)' or 'beta in range(nb_basis_functions)' ? (symmetry alpha/beta)
    ##Multipole moments at natural centers P_{\alpha,\beta} are computed for beta >=alpha only
    #by symmetry (the contracted GTOs basis functions are REAL)
    multipole_moments_natural_centers=[[[[compute_DMA_multipole_moment_natural_expansion_center_primitive_GTOs(k,q,alpha,beta,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,correspondence_basis_pGTOs_atom_index,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,position_nuclei_associated_basis_function_pGTO) for q in range(-k,k+1) ] for k in range(0,l_max(alpha,beta,angular_momentum_numbers_primitive_GTOs)+1)] for beta in range(alpha,total_nb_primitive_GTOs) ] for alpha in range(total_nb_primitive_GTOs)]
    #Multipole moments with respect to products of (PRIMITIVE) GTOs are computed
    #=> the contraction of the basis set (pGTOs [primitive]-->cGTOs [contracted]) is taken
    #into account via modified "contracted" density matrix coefficients :
    #D_{mu1,mu2}=sum_{alpha,beta} {D_{alpha,beta}x(C_{alpha}^{mu1})* x C_{beta}^{mu2} }       
    
    ###OLD : (matrix {Q_(k,q)^{alpha,beta}}_{alpha,beta} at fixed angular momenta numbers (k,q)
    ##multipole_moments_natural_centers=[[compute_multipole_moment_natural_expansion_center(k,q,alpha,beta,exponents_basis_sets) for alpha in range(nb_basis_functions)] for beta in range(nb_basis_functions)]
  
    t_end_1=time.clock()
    

    
    ##BEWARE : compared to the FINAL multipole moments : multipole moments with respect to 
    #'natural' overlap centers "multipole_moments_natural_centers" are not multiplied
    #by the density matrix coefficients at this stage
    #==> not comparable to the final multipole moments in terms of order of magnitude.
    
    logfile_DMA.write('Time to compute multipole_moments_natural_centers : '+str(t_end_1-t_begin_1))
    logfile_DMA.write("\n")
    logfile_DMA.write(' --------------------------- ')
    logfile_DMA.write('\n')
    logfile_DMA.write("\n")
        
    
    #Checking total quadrupolar moment computed from multipoles at all 'natural' overlap centers
    #==> should yield the same result as 'computes_total_quadrupole_from_local_multipoles_DMA_sites()'
    #i.e. total quadrupolar moment computed from already redistributed multipoles (monopoles, dipoles, quadrupoles)
    total_quadrupolar_moment_from_overlap_centers=computes_total_quadrupole_spherical_from_local_multipoles_overlap_centers(0.,0.,0.,multipole_moments_natural_centers,density_matrix_coefficient_pGTOs,total_nb_primitive_GTOs,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO)
    logfile_DMA.write('total_quadrupolar_moment_from_overlap_centers (atomic units)')
    logfile_DMA.write("\n")
    logfile_DMA.write(str(total_quadrupolar_moment_from_overlap_centers))
    logfile_DMA.write("\n")
    logfile_DMA.write('|(Q_2)_{tot}| = '+str(np.linalg.norm(total_quadrupolar_moment_from_overlap_centers)))
    logfile_DMA.write('\n')
    logfile_DMA.write("\n")
    
    
    positions_final_DMA_expansion_sites=coordinates_final_expansion_centers(atomic_coordinates,correspondence_basis_pGTOs_atom_index,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO,total_nb_primitive_GTOs)

    logfile_DMA.write('POSITIONS OF THE FINAL DMA EXPANSION SITES :')
    logfile_DMA.write("\n")
    logfile_DMA.write(str(positions_final_DMA_expansion_sites))
    logfile_DMA.write('\n')
    logfile_DMA.write("\n")
    
    ##M=number_final_expansion_centers(atomic_coordinates,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,total_nb_primitive_GTOs,correspondence_basis_pGTOs_atom_index)
    M=len(positions_final_DMA_expansion_sites)
    
    logfile_DMA.write('number_final_expansion_centers = '+str(M))
    logfile_DMA.write('\n')
    logfile_DMA.write("\n")
    
    ##############################################################################################
    ##REDISTRIBUTION OF THE MULTIPOLES TO THE FINAL DMA EXPANSION SITES
    t_begin_2=time.clock()

    #PARALLELIZATION OVER i [number of final sites], l and m [angular moment numbers] (by vectorization):
    multipole_moments_final_expansion_sites=[[[compute_DMA_multipole_moment_final_expansion_center_one_site(l,m,positions_final_DMA_expansion_sites[i][0],positions_final_DMA_expansion_sites[i][1],positions_final_DMA_expansion_sites[i][2],multipole_moments_natural_centers,density_matrix_coefficient_pGTOs,total_nb_primitive_GTOs,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,correspondence_basis_pGTOs_atom_index,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,QM_data.atomnos,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,redistribution_strategy,positions_final_DMA_expansion_sites,logfile_DMA) for m in range(-l,l+1)] for l in range(0,l_max_user[i]+1)] for i in range(M)]
    
    t_end_2=time.clock()
    logfile_DMA.write('Time to redistribute multipole moments at final centers : '+str(t_end_2-t_begin_2))
    logfile_DMA.write("\n")
    logfile_DMA.write(' --------------------------- ')
    logfile_DMA.write('\n')
    logfile_DMA.write("\n")
    
    
    t_end=time.clock()
    logfile_DMA.write('Time to compute multipole moments : '+str(t_end-t_begin))
    logfile_DMA.write('\n')
    logfile_DMA.write("\n")
    
    ##ANOTHER FUNCTION appealed after to write into an output file ? (e.g. of 'dma.punch' type format)
    return multipole_moments_final_expansion_sites
################################################################################################################################



#END OF MAIN FUNCTIONS
##################################################################################################################
##################################################################################################################

################################################################################################################################
#TEST function (for debugging purposes only) to test the multipole calculations with an ad-hoc density matrix
#(e.g. corresponding to simply ATOMIC occupations)
def compute_DMA_multipole_moment_final_expansion_center_all_sites_all_orders_TEST(QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,redistribution_strategy,l_max_user):
    
    t_begin=time.clock()
    
    if (redistribution_strategy==1):
        print('Stone redistribution_strategy')
    elif (redistribution_strategy==2):
        print('Vigné-Maeder redistribution strategy')
    print(' ')
    
    if (boolean_all_atomic_sites):
        print('All atomic sites kept as final DMA expansion centers')
        print(' ')
    else:
        print('Not all atomic sites kept as final DMA expansion centers. Omitted atoms indexes are :')
        print(atomic_sites_to_omit)
        print(' ')
    
    if (index_philosophy==1):
        print('AMOEBA philosophy : only nuclei kept as final sites')

    elif (index_philosophy==2):
        print('Nuclei AND bond centers are kept as final DMA sites')

    elif (index_philosophy==3):
        print('Nuclei AND user-defined additional sites are kept as final DMA sites')
      
    elif (index_philosophy==4):
        print('User-defined sites are kept as final DMA sites')
      
    elif (index_philosophy==5):
        print('All overlap centers kept as final DMA expansion sites')
    
    print(' ')

    ##############################################################################################
    #Useful informations are extracted from the QM output (stored in 'information_QM_calculation')
    #[extraction of relevant info from QM output file : done once and for all, 
    #before (distributed) multipole moments calculations]
    
    
    ##################################################
    #####################
    #Test for benzene :
    
    nb_atoms=12
    
    nb_contracted_shells=24
    
    nb_basis_functions=24

     
    nb_primitive_GTOs=[[3,3,3,3,3,3,1,1,1,1,1,1],24]
    
    density_matrix_coefficient_contracted_GTOs=[[1.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,1.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,3./3.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,],
                                                [0,0,0,1.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,1.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,3/3.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,1.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,1.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,3/3.,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,1.,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,1.,0,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,3/3.,0,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,1.,0,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,1.,0,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,3/3.,0,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.,0,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.,0,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3/3.,0,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1/2.,0,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1/2.,0,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1/2.,0,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1/2.,0,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1/2.,0],
                                                [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1/2.]]
    
    density_matrix_coefficient_contracted_GTOs=np.dot(2,density_matrix_coefficient_contracted_GTOs)
  
     
    angular_momentum_numbers_primitive_GTOs=[[0, 0], [0, 0], [1,-1], [0, 0], [0, 0], [1,-1], [0, 0], [0, 0], [1,-1], [0, 0], [0, 0], [1,-1], [0, 0], [0, 0], [1,-1], [0, 0], [0, 0], [1,-1], [0, 0], [0, 0],[0, 0],[0, 0],[0, 0],[0, 0]]
    print('angular_momentum_numbers_primitive_GTOs')
    print(angular_momentum_numbers_primitive_GTOs)
    print(' ')
    
    tab_correspondence_index_contracted_GTOs_contracted_shells=[i for i in range(nb_basis_functions)]
    tab_correspondence_index_primitive_GTOs_primitive_shells=[i for i in range(nb_basis_functions)]
    
    
    #####################
    #Test for dioxygen (O2) :
    """
    nb_atoms=2
    
    nb_contracted_shells=8
     
    nb_primitive_GTOs=[[4,4],8]
    
    density_matrix_coefficient_contracted_GTOs=[[1.,0,0,0,0,0,0,0],
                                                [0,1.,0,0,0,0,0,0],
                                                [0,0,1.,0,0,0,0,0],
                                                [0,0,0,1.,0,0,0,0],
                                                [0,0,0,0,1.,0,0,0],
                                                [0,0,0,0,0,1.,0,0],
                                                [0,0,0,0,0,0,1.,0],
                                                [0,0,0,0,0,0,0,1.]]
    
    density_matrix_coefficient_contracted_GTOs=np.dot(2,density_matrix_coefficient_contracted_GTOs)
  
     
    angular_momentum_numbers_primitive_GTOs=[[0, 0], [0, 0], [1,-1],[1,0], [0, 0], [0, 0], [1,-1], [1,0]]
    print('angular_momentum_numbers_primitive_GTOs')
    print(angular_momentum_numbers_primitive_GTOs)
    print(' ')
    
    nb_basis_functions=8
    """
    #####################
    
    
    ##################################################
    
    tab_correspondence_index_contracted_GTOs_contracted_shells=[i for i in range(nb_basis_functions)]
    tab_correspondence_index_primitive_GTOs_primitive_shells=[i for i in range(nb_basis_functions)]
    
    nb_primitive_shells=nb_contracted_shells
    
    nb_contracted_GTOs=nb_contracted_shells

    total_nb_primitive_GTOs=nb_primitive_GTOs[1]
    
    basis_set_exponents_primitive_GTOs=[1 for i in range(nb_basis_functions)]
    
    atomic_coordinates=QM_data.atomcoords[len(QM_data.atomcoords)-1]
    
    print('atomic_coordinates')
    print(atomic_coordinates)
    print(' ')
    
    position_nuclei_associated_basis_function_pGTO=import_position_nuclei_associated_basis_function_pGTO(nb_primitive_GTOs,nb_atoms,QM_data)
    print('position_nuclei_associated_basis_function_pGTO')
    print(position_nuclei_associated_basis_function_pGTO)
    print(' ')
    
    
    correspondence_index_contracted_GTOs_primitive_GTOs=[[i] for i in range(nb_basis_functions)]
    
    correspondence_index_primitive_GTOs_contracted_GTOs=[[i] for i in range(nb_basis_functions)]
    
    ############
    #VERIFICATION :
        
    #Information used by 'compute_scalar_product_two_primitive_GTOs()'
    #For each primitive GTO : gives the index of the atom on which it is centered
    correspondence_basis_pGTOs_atom_index=import_correspondence_pGTOs_atom_index(nb_primitive_GTOs,nb_atoms)
    
    #Contraction coefficients given in e/bohr^(3/2) (atomic units) by Gaussian output file
    contraction_coefficients_pSHELLS_to_cSHELLS=[[1 if i==j else 0 for j in range(nb_basis_functions)] for i in range(nb_basis_functions)]

    #Density matrix needed in the basis of PRIMITIVE GTOs for multipole moments calculations
    #density_matrix_coefficient_pGTOs=compute_density_matrix_coefficient_pGTOs(QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,nb_primitive_GTOs,density_matrix_coefficient_contracted_GTOs,contraction_coefficients_pSHELLS_to_cSHELLS,tab_correspondence_index_contracted_GTOs_contracted_shells,tab_correspondence_index_primitive_GTOs_primitive_shells,correspondence_index_contracted_GTOs_primitive_GTOs,correspondence_index_primitive_GTOs_contracted_GTOs,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO,total_nb_primitive_GTOs,nb_contracted_GTOs,nb_primitive_shells,nb_contracted_shells)
    density_matrix_coefficient_pGTOs=density_matrix_coefficient_contracted_GTOs
    print('density_matrix_coefficient_pGTOs')
    #print(density_matrix_coefficient_pGTOs)
    print(' ')


    #Gram matrix (nb_contracted_GTOs² scalar products) of contracted GTOs :    
    scalar_products_contracted_GTOs=[[compute_scalar_product_two_contracted_GTOs(i,j,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,nb_primitive_GTOs,correspondence_index_contracted_GTOs_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs,contraction_coefficients_pSHELLS_to_cSHELLS,tab_correspondence_index_contracted_GTOs_contracted_shells,tab_correspondence_index_primitive_GTOs_primitive_shells,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO) for j in range(nb_contracted_GTOs)] for i in range(nb_contracted_GTOs)]
        
    ####################################
    #VERIFICATION total electronic charge recovered with the CONTRACTED density matrix expression of the density :
    Q_tot=0
    for mu in range(nb_contracted_GTOs):
        for nu in range(nb_contracted_GTOs):
            #for sigma in range(len(density_matrix_coefficient_contracted_GTOs)):
            Q_tot+=density_matrix_coefficient_contracted_GTOs[mu][nu]*scalar_products_contracted_GTOs[mu][nu]
    print('Total charge with D^{cGTOs} = '+str(Q_tot))
    print(' ')
    
    #####################################
    
    #Gram matrix (nb_primitive_GTOs² scalar products) of NORMALIZED primitive GTOs :    
    #(N_{alpha}*N_{beta}*<\chi_{alpha}^{pGTO} | \chi_{beta}^{pGTO}>  where \chi_{alpha}^{pGTO}(.) is a NON-normalized solid spherical harmonic times a gaussian)
    scalar_products_primitive_GTOs=[[compute_normalization_coefficient_primitive_GTO(alpha,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)*compute_normalization_coefficient_primitive_GTO(beta,QM_data,boolean_cartesian_D_shells,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)*compute_scalar_product_two_primitive_GTOs(alpha,beta,boolean_cartesian_D_shells,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO) for beta in range(total_nb_primitive_GTOs)] for alpha in range(total_nb_primitive_GTOs)]
    
    
    """
    ####################################
    #VERIFICATION total electronic charge recovered with the PRIMITIVE density matrix expression of the density :
    Q_tot_bis=0
    for i in range(total_nb_primitive_GTOs): 
           
        #normalization_coeff_pGTO_i=extraction_QM_info.compute_normalization_coefficient_primitive_GTO(i,QM_data,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)

        for j in range(i,total_nb_primitive_GTOs):
            
            #normalization_coeff_pGTO_j=extraction_QM_info.compute_normalization_coefficient_primitive_GTO(j,QM_data,correspondence_basis_pGTOs_atom_index,position_nuclei_associated_basis_function_pGTO,angular_momentum_numbers_primitive_GTOs,basis_set_exponents_primitive_GTOs)

            Q_tot_bis+=density_matrix_coefficient_pGTOs[i][j]*scalar_products_primitive_GTOs[i][j]
    
    print('Total charge with D^{pGTOs} = '+str(Q_tot_bis))
    print(' ')
    """
    #####################################
    
    
    t_begin_1=time.clock()

    multipole_moments_natural_centers=[[[[compute_DMA_multipole_moment_natural_expansion_center_primitive_GTOs(k,q,alpha,beta,QM_data,boolean_cartesian_D_shells,boolean_cartesian_F_shells,correspondence_basis_pGTOs_atom_index,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,position_nuclei_associated_basis_function_pGTO) for q in range(-k,k+1) ] for k in range(0,l_max(alpha,beta,angular_momentum_numbers_primitive_GTOs)+1)] for beta in range(alpha,total_nb_primitive_GTOs) ] for alpha in range(total_nb_primitive_GTOs)]
    
    t_end_1=time.clock()
    

    print('Time to compute multipole_moments_natural_centers : '+str(t_end_1-t_begin_1))
    print(' --------------------------- ')
    print(' ')
        
    
    """
    #Checking total quadrupolar moment computed from multipoles at 'natural' overlap centers
    total_quadrupolar_moment_from_overlap_centers=computes_total_quadrupole_spherical_from_local_multipoles_overlap_centers(0,0,0,multipole_moments_natural_centers,density_matrix_coefficient_pGTOs,total_nb_primitive_GTOs,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO)
    print('total_quadrupolar_moment_from_overlap_centers')
    print(total_quadrupolar_moment_from_overlap_centers)
    print('|(Q_2)_{tot}| = '+str(np.linalg.norm(total_quadrupolar_moment_from_overlap_centers)))
    print(' ')
    """
    
    positions_final_DMA_expansion_sites=coordinates_final_expansion_centers(atomic_coordinates,correspondence_basis_pGTOs_atom_index,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO,total_nb_primitive_GTOs)

    print('POSITIONS OF THE FINAL DMA EXPANSION SITES :')
    print(positions_final_DMA_expansion_sites)
    print(' ')        
    
    ##M=number_final_expansion_centers(atomic_coordinates,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,total_nb_primitive_GTOs,correspondence_basis_pGTOs_atom_index)
    M=len(positions_final_DMA_expansion_sites)
    
    print('number_final_expansion_centers = '+str(M))
    print(' ')
    
    ##############################################################################################
    ##REDISTRIBUTION OF THE MULTIPOLES TO THE FINAL DMA EXPANSION SITES
    t_begin_2=time.clock()

    #PARALLELIZATION OVER i [number of final sites], l and m [angular moment numbers] (by vectorization):
    multipole_moments_final_expansion_sites=[[[compute_DMA_multipole_moment_final_expansion_center_one_site(l,m,positions_final_DMA_expansion_sites[i][0],positions_final_DMA_expansion_sites[i][1],positions_final_DMA_expansion_sites[i][2],multipole_moments_natural_centers,density_matrix_coefficient_pGTOs,total_nb_primitive_GTOs,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,correspondence_basis_pGTOs_atom_index,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,QM_data.atomnos,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,redistribution_strategy,positions_final_DMA_expansion_sites) for m in range(-l,l+1)] for l in range(0,l_max_user[i]+1)] for i in range(M)]
    
    t_end_2=time.clock()
    print('Time to redistribute multipole moments at final centers : '+str(t_end_2-t_begin_2))
    print(' --------------------------- ')
    print(' ')
    
    
    t_end=time.clock()
    print('Time to compute multipole moments : '+str(t_end-t_begin))
    print(' ')
    ##ANOTHER FUNCTION appealed after to write into an output file ? (e.g. of 'dma.punch' type format)
    return multipole_moments_final_expansion_sites
################################################################################################################################



##################################################################################################################
##ESSENTIAL AUXILIARY FUNCTIONS USED FOR THE REDISTRIBUTION OF MULTIPOLES

##############################################################################
def real_part_redistributed_complex_multipoles(l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers):
    
    real_part_redistributed_complex_multipoles_alpha_beta=0
    
    for k in range(0,min(l_max(alpha_1,beta_1,angular_momentum_numbers_primitive_GTOs)+1,l+1)):
        
        for q in range(-k,k+1):
            
            if (q!=0):
    
                contribution_1=(1/math.sqrt(2))*binomial_coefficient_real_spherical_harmonics(k,q,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO)*density_matrix_coefficient_pGTOs[alpha_1][beta_1]*multipole_moments_natural_centers[alpha_1][beta_1-alpha_1][k][abs(q)+k]
                                
                if (q>0):
                    contribution_1=(-1)**q *contribution_1
                
                if (m!=q):
                    
                    contribution_1=(1/math.sqrt(2)) * contribution_1
                    
                    if (m>q):
                        contribution_1=(-1)**(m-q) * contribution_1
                        
                contribution_2=0
                
                if (m != q):
                
                    contribution_2=0.5*binomial_coefficient_real_spherical_harmonics_bis(k,q,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO)*density_matrix_coefficient_pGTOs[alpha_1][beta_1]*multipole_moments_natural_centers[alpha_1][beta_1-alpha_1][k][-abs(q)+k]
                                    
                    if (q>0):
                        contribution_2=(-1)**(q+1) * contribution_2
                                        
                    if (m>q):
                        contribution_2=(-1)**(m-q+1) * contribution_2
                       
                real_part_redistributed_complex_multipoles_alpha_beta+=(contribution_1-contribution_2)
               
            elif (q==0):
                
                contribution_0=binomial_coefficient_real_spherical_harmonics(k,0,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO)*density_matrix_coefficient_pGTOs[alpha_1][beta_1]*multipole_moments_natural_centers[alpha_1][beta_1-alpha_1][k][k]
                       
                if (m!=0):
                    
                    contribution_0=(1/math.sqrt(2))*contribution_0
                    
                    if (m>0):
                        contribution_0=(-1)**m *contribution_0

                real_part_redistributed_complex_multipoles_alpha_beta+=contribution_0
   
        
    return real_part_redistributed_complex_multipoles_alpha_beta
##############################################################################


##############################################################################
def imaginary_part_redistributed_complex_multipoles(l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers):
    
    imaginary_part_redistributed_complex_multipoles=0
    
    for k in range(0,min(l_max(alpha_1,beta_1,angular_momentum_numbers_primitive_GTOs)+1,l+1)):
        
        for q in range(-k,k+1):
            
            if (q!=0):
    
                contribution_1=0
                
                #If m==q => contribution_1 must be =0
                if (m!=q):
                    
                    contribution_1=-0.5*binomial_coefficient_real_spherical_harmonics_bis(k,q,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO)*density_matrix_coefficient_pGTOs[alpha_1][beta_1]*multipole_moments_natural_centers[alpha_1][beta_1-alpha_1][k][abs(q)+k]
                                
                    if (q>0):
                        
                        contribution_1=(-1)**q * contribution_1
                                    
                    if (m>q):
                        
                        contribution_1=(-1)**(m-q+1) * contribution_1
                                
                
                contribution_2=-(1/math.sqrt(2))*binomial_coefficient_real_spherical_harmonics(k,q,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO)*density_matrix_coefficient_pGTOs[alpha_1][beta_1]*multipole_moments_natural_centers[alpha_1][beta_1-alpha_1][k][-abs(q)+k]
                                    
                if (q>0):
                    contribution_2=(-1)**(q+1) * contribution_2
                        
                if (m!=q):
                    
                    contribution_2=(1/math.sqrt(2)) * contribution_2
                    
                    if (m>q):
                        contribution_2=(-1)**(m-q) * contribution_2
                    
                imaginary_part_redistributed_complex_multipoles+=(contribution_1+contribution_2)
            
            elif (q==0):
            
                contribution_0=binomial_coefficient_real_spherical_harmonics_bis(k,0,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO)*density_matrix_coefficient_pGTOs[alpha_1][beta_1]*multipole_moments_natural_centers[alpha_1][beta_1-alpha_1][k][k]
                   
                if (m!=0):
                    
                    contribution_0= -(1/math.sqrt(2))*contribution_0
                    
                    if (m>0):
                        
                        contribution_0=(-1)**(m+1)*contribution_0
                                                                    
                imaginary_part_redistributed_complex_multipoles+=contribution_0

    return imaginary_part_redistributed_complex_multipoles
##############################################################################



##############################################################################
#Coefficient involved in the multipole redistribution from one site to another :
#= math.sqrt(scipy.special.binom(l+m,k+q)*scipy.special.binom(l-m,k-q)) * | \vec{P}_{alpha,beta}-\vec{S} |**(l-k) * Y_(l-k)^(|m-q|) ( (\vec{P}_{alpha,beta}-\vec{S}) | \vec{P}_{alpha,beta}-\vec{S} |)
#with Y_(l-k)^(|m-q|) (.) the REAL spherical harmonics
def binomial_coefficient_real_spherical_harmonics(k,q,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO):
    
    tab_position_center_S=[x_S,y_S,z_S]

    coefficient_redistribution=0
        
    ##BEWARE : Stone's code => 'relative radius' for final expansion sites
    #"The actual distances from an overlap centre to the sites are
    #scaled by dividing by the radii of the sites, 
    #(default radius for all sites = 0.65 angstroms)
    #radius_scaling=1./0.65
    radius_scaling=1

    #\vec{a}=\vec{P}_{alpha,beta}-\vec{S}
    vector_a=[radius_scaling*(coordinates_natural_center(alpha_1,beta_1,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO)[j]-tab_position_center_S[j]) for j in range(0,3)]
    

    #(m-q) can be > (in absolute value) to (l-k) (\in [0,l]), cf. redistribution formula
    #==> by convention Y_{l-k}^{m-q} = 0 in that case
    #[spherical harmonic not defined in that case]
    if (abs(m-q)<=abs(l-k)):
        
        #'Solid harmonic' |a|^(l-k) * Y_{l-k}^{m-q}(\vec{a}/|\vec{a})
        #=sum of homogeneous polynoms of degree (l-k) in a_x, a_y, a_z
        
        if ((l-k)<=4):
            coeff_harmonics_cartesian=conversion_spherical_harmonics_cartesian_homogeneous_polynoms(l-k,abs(m-q))
        else:
            #New function 05/08/20 :
            coeff_harmonics_cartesian=computes_coefficient_solid_harmonic_l_m_list_format(l-k,abs(m-q))
        
        number_homogeneous_polynoms=coeff_harmonics_cartesian[0]
        tab_indexes_polynoms=coeff_harmonics_cartesian[1]
        weights_spherical_harmonics_to_cartesian_alpha=coeff_harmonics_cartesian[2]

        for i in range(number_homogeneous_polynoms):
        
            # += w_i(l-k,m-q) * [a_x**n_i(l-k,m-q)*a_y**m_i(l-k,m-q)*a_z**t_i(l-k,m-q)]
            coefficient_redistribution+=weights_spherical_harmonics_to_cartesian_alpha[i]*(vector_a[0]**tab_indexes_polynoms[i][0])*(vector_a[1]**tab_indexes_polynoms[i][1])*(vector_a[2]**tab_indexes_polynoms[i][2])
                
        ##coefficient_redistribution*=scipy.spatial.distance.pdist([coordinates_natural_center(alpha_1,beta_1,basis_set_exponents,atomic_coordinates,output_cc_get_gbasis),tab_position_center_S])[0]**(l-k)
        
        ##*coefficients binomial c_(k,q)^(l,m) :
        binomial_coeff=math.sqrt(scipy.special.binom(l+m,k+q)*scipy.special.binom(l-m,k-q))
        
        ##Harmonique sphérique (l-k,m-q) [polynôme homogène de degré (l-k)] évaluée en :
        #(coordinates_natural_center(alpha,beta,basis_set_exponents)-tab_position_center_S)/norm(coordinates_natural_center(alpha,beta,basis_set_exponents)-tab_position_center_S)

        coefficient_redistribution=coefficient_redistribution*binomial_coeff
        
            
        #Conversion from Ang**(l-k) to Bohr**{l-k} (atomic units) as multiplied in the
        #multipole redistribution formula by (Q_(k,q)^{alpha,beta})_{P_{alpha,beta}} which is in Bohr**k
        #in the main function 'compute_DMA_multipole_moment_final_expansion_center_one_site()'
        return ((1/conversion_bohr_angstrom)**(l-k))*coefficient_redistribution
        
    else:
        #Case |m-q| > |l-k|
        return 0
##############################################################################
    


##############################################################################
#Coefficient involved in the multipole redistribution from one site to another
#Same function as 'binomial_coefficient_real_spherical_harmonics()' (function above)
#replacing the (REAL) spherical harmonic Y(l-k,abs(m-q)) by Y(l-k,-abs(m-q)) :
#= math.sqrt(scipy.special.binom(l+m,k+q)*scipy.special.binom(l-m,k-q)) * | \vec{P}_{alpha,beta}-\vec{S} |**(l-k) * Y_(l-k)^(-|m-q|) ( (\vec{P}_{alpha,beta}-\vec{S}) | \vec{P}_{alpha,beta}-\vec{S} |)
#with Y_(l-k)^(|m-q|) (.) the REAL spherical harmonics
def binomial_coefficient_real_spherical_harmonics_bis(k,q,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO):
    
    tab_position_center_S=[x_S,y_S,z_S]

    coefficient_redistribution=0
    
    ##BEWARE : Stone's code => 'relative radius' for final expansion sites
    #"The actual distances from an overlap centre to the sites are
    #scaled by dividing by the radii of the sites, 
    #(default radius for all sites = 0.65 angstroms)
    #radius_scaling=1./0.65
    radius_scaling=1
    
    #\vec{a}=\vec{P}_{alpha,beta}-\vec{S}
    vector_a=[radius_scaling*(coordinates_natural_center(alpha_1,beta_1,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO)[j]-tab_position_center_S[j]) for j in range(0,3)]
    

    #(m-q) can be > (in absolute value) to (l-k) (\in [0,l]), cf. redistribution formula
    #==> by convention Y_{l-k}^{m-q} = 0 in that case
    #[spherical harmonic not defined in that case]
    if (abs(m-q)<=abs(l-k)):
        
        #'Solid harmonic' |a|^(l-k) * Y_{l-k}^{m-q}(\vec{a}/|\vec{a})
        #=sum of homogeneous polynoms of degree (l-k) in a_x, a_y, a_z
        
        if ((l-k)<=4):
            coeff_harmonics_cartesian=conversion_spherical_harmonics_cartesian_homogeneous_polynoms(l-k,-abs(m-q))
        else:
            #New function 05/08/20 :
            coeff_harmonics_cartesian=computes_coefficient_solid_harmonic_l_m_list_format(l-k,-abs(m-q))
        
        number_homogeneous_polynoms=coeff_harmonics_cartesian[0]
        tab_indexes_polynoms=coeff_harmonics_cartesian[1]
        weights_spherical_harmonics_to_cartesian_alpha=coeff_harmonics_cartesian[2]

        for i in range(number_homogeneous_polynoms):
        
            # += w_i(l-k,m-q) * [a_x**n_i(l-k,m-q)*a_y**m_i(l-k,m-q)*a_z**t_i(l-k,m-q)]
            coefficient_redistribution+=weights_spherical_harmonics_to_cartesian_alpha[i]*(vector_a[0]**tab_indexes_polynoms[i][0])*(vector_a[1]**tab_indexes_polynoms[i][1])*(vector_a[2]**tab_indexes_polynoms[i][2])
                
        ##coefficient_redistribution*=scipy.spatial.distance.pdist([coordinates_natural_center(alpha_1,beta_1,basis_set_exponents,atomic_coordinates,output_cc_get_gbasis),tab_position_center_S])[0]**(l-k)
        
        ##*coefficients binomial c_(k,q)^(l,m) :
        binomial_coeff=math.sqrt(scipy.special.binom(l+m,k+q)*scipy.special.binom(l-m,k-q))
        
        ##Harmonique sphérique (l-k,m-q) [polynôme homogène de degré (l-k)] évaluée en :
        #(coordinates_natural_center(alpha,beta,basis_set_exponents)-tab_position_center_S)/norm(coordinates_natural_center(alpha,beta,basis_set_exponents)-tab_position_center_S)

        coefficient_redistribution=coefficient_redistribution*binomial_coeff
        
        
        
        #Conversion from Ang**(l-k) to Bohr**{l-k} (atomic units) as multiplied in the
        #multipole redistribution formula by (Q_(k,q)^{alpha,beta})_{P_{alpha,beta}} which is in Bohr**k
        #in the main function 'compute_DMA_multipole_moment_final_expansion_center_one_site()'
        return ((1/conversion_bohr_angstrom)**(l-k))*coefficient_redistribution
        
    else:
        #Case |m-q| > |l-k|
        return 0
##############################################################################
    

##############################################################################
#Coefficient involved in the multipole redistribution from one site to another
#for the (FALSE ?) redistribution formula involving REAL multipoles
#= math.sqrt(scipy.special.binom(l+m,k+q)*scipy.special.binom(l-m,k-q)) * | \vec{P}_{alpha,beta}-\vec{S} |**(l-k) * Y_(l-k)^(m-q) ( (\vec{P}_{alpha,beta}-\vec{S}) | \vec{P}_{alpha,beta}-\vec{S} |)
def binomial_coefficient_real_spherical_harmonics_real_multipoles(k,q,l,m,alpha_1,beta_1,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO):
    
    tab_position_center_S=[x_S,y_S,z_S]

    coefficient_redistribution=0
        
    ##BEWARE : Stone's code => 'relative radius' for final expansion sites
    #"The actual distances from an overlap centre to the sites are
    #scaled by dividing by the radii of the sites, 
    #(default radius for all sites = 0.65 angstroms)
    ##radius_scaling=1./0.65
    radius_scaling=1

    #\vec{a}=\vec{P}_{alpha,beta}-\vec{S}
    vector_a=[radius_scaling*(coordinates_natural_center(alpha_1,beta_1,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO)[j]-tab_position_center_S[j]) for j in range(0,3)]
    
    

    #(m-q) can be > (in absolute value) to (l-k) (\in [0,l]), cf. redistribution formula
    #==> by convention Y_{l-k}^{m-q} = 0 in that case
    #[spherical harmonic not defined in that case]
    if (abs(m-q)<=abs(l-k)):
        
        #'Solid harmonic' |a|^(l-k) * Y_{l-k}^{m-q}(\vec{a}/|\vec{a})
        #=sum of homogeneous polynoms of degree (l-k) in a_x, a_y, a_z
        
        if ((l-k)<=4):
            coeff_harmonics_cartesian=conversion_spherical_harmonics_cartesian_homogeneous_polynoms(l-k,m-q)
        else:
            #New function 05/08/20 :
            coeff_harmonics_cartesian=computes_coefficient_solid_harmonic_l_m_list_format(l-k,m-q)
            
        
        number_homogeneous_polynoms=coeff_harmonics_cartesian[0]
        tab_indexes_polynoms=coeff_harmonics_cartesian[1]
        weights_spherical_harmonics_to_cartesian_alpha=coeff_harmonics_cartesian[2]

        for i in range(number_homogeneous_polynoms):
        
            # += w_i(l-k,m-q) * [a_x**n_i(l-k,m-q)*a_y**m_i(l-k,m-q)*a_z**t_i(l-k,m-q)]
            coefficient_redistribution+=weights_spherical_harmonics_to_cartesian_alpha[i]*(vector_a[0]**tab_indexes_polynoms[i][0])*(vector_a[1]**tab_indexes_polynoms[i][1])*(vector_a[2]**tab_indexes_polynoms[i][2])
                
        ##coefficient_redistribution*=scipy.spatial.distance.pdist([coordinates_natural_center(alpha_1,beta_1,basis_set_exponents,atomic_coordinates,output_cc_get_gbasis),tab_position_center_S])[0]**(l-k)
        
        ##*coefficients binomial c_(k,q)^(l,m) :
        binomial_coeff=math.sqrt(scipy.special.binom(l+m,k+q)*scipy.special.binom(l-m,k-q))
        
        ##Harmonique sphérique (l-k,m-q) [polynôme homogène de degré (l-k)] évaluée en :
        #(coordinates_natural_center(alpha,beta,basis_set_exponents)-tab_position_center_S)/norm(coordinates_natural_center(alpha,beta,basis_set_exponents)-tab_position_center_S)

        coefficient_redistribution=coefficient_redistribution*binomial_coeff
   
        #Conversion from Ang**(l-k) to Bohr**{l-k} (atomic units) as multiplied in the
        #multipole redistribution formula by (Q_(k,q)^{alpha,beta})_{P_{alpha,beta}} which is in Bohr**k
        #in the main function 'compute_DMA_multipole_moment_final_expansion_center_one_site()'
        return ((1/conversion_bohr_angstrom)**(l-k))*coefficient_redistribution
        
    else:
        #Case |m-q| > |l-k|
        return 0
##############################################################################


##############################################################################
#Weight/percentage of redistributed multipole moments from 'natural' 
#center P_{alpha,beta} allocated to 'final' expansion center S 
# =^{def} C_{alpha,beta}^{\vec{S}}
#(S is in general itself a natural expansion center, but not necessarily 
#depending on user input [additional expansion sites through 'user_final_sies' variable])
##############################################"
#THIS FUNCTION SHOULD BE CALLED ONLY for natural expansion centers P_{alpha,beta}
#that DO NOT coincide with ANY of the final DMA sites (otherwise division by 0
#in the Vigné-Maeder redistribution strategy, see below) 
#i.e. after calling the function 'overlap_center_is_DMA_final_expansion_site()'
#and if the latter has rturned 'FALSE'.
#cf. in main function 'compute_DMA_multipole_moment_final_expansion_center_one_site()'
#######################
#=> Stone strategy : = 1 if S is the nearest neighbor of P_{alpha,beta}, 0 otherwise 
#(case 'redistribution_strategy=1' by convention)
#=> Vigné-Maeder strategy : = (1/dist(S,P_{alpha,beta})/sum_i (1/dist(S_i,P_{alpha,beta})) 
#here the sum on "i" runs over the 'final' expansion sites S_i
#(case 'redistribution_strategy=2' by convention)
def weight_redistribution_multipoles(alpha,beta,x_S,y_S,z_S,basis_set_exponents_primitive_GTOs,correspondence_basis_pGTOs_atom_index,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,redistribution_strategy,positions_final_DMA_expansion_sites):
    
    tab_position_center_S=[x_S,y_S,z_S]

    #######################################################################
    #STONE's strategy (redistribute to the nearest neighbor 
    #[i.e. nearest final DMA site, e.g. a nuclei or a bond center])
    if (redistribution_strategy==1):
        
        position_closest_final_site=compute_position_closest_final_site(alpha,beta,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO,atomic_coordinates,index_philosophy,positions_final_DMA_expansion_sites)
    
        
        #Remark : if only one final DMA site closest to this overlap center P_{alpha,beta}
        #=> len(position_closest_final_site) ==1
        #=> weight is = 1 only for the closest final site, 0 otherwise

        #If TWO OR SEVERAL final DMA sites are the closest to this overlap center P_{alpha,beta}
        #=> len(position_closest_final_site>=2
        #=> weight is = 1/nb_equally_close_sites  for the closest final sites, 0 otherwise
            
        for k in range(len(position_closest_final_site)):
            
            ##If S is actually ONE of the two final expansion site 
            ##the (equally) closest to P_{alpha,beta}
            if (scipy.spatial.distance.pdist([tab_position_center_S,position_closest_final_site[k]])[0]<epsilon):
                
                return 1/len(position_closest_final_site)
   
            
        #The final DMA expansion site S is none of the two or several final DMA expansion sites
        #the closest to the overlap center P_{alpha,beta}
        return 0
        
    ###############################################################################
    #Vigné-Maeder strategy 
    #(see Ref. Fabienne Vigné-Maeder, and Pierre Claverie, J. Chem. Phys. 88, 4934 (1988))
    elif (redistribution_strategy==2):
                
        sum_inverse_distances_to_final_expansion_sites=0
        
        nb_primitive_GTOs=len(basis_set_exponents_primitive_GTOs)
        
        tab_coordinates_final_expansion_centers=coordinates_final_expansion_centers(atomic_coordinates,correspondence_basis_pGTOs_atom_index,boolean_all_atomic_sites,atomic_sites_to_omit,user_extra_final_sites,index_philosophy,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO,nb_primitive_GTOs)
    
        for k in range(len(tab_coordinates_final_expansion_centers)):
            
            tab_position_center_S_k=tab_coordinates_final_expansion_centers[k]

            if (scipy.spatial.distance.pdist([tab_position_center_S_k,coordinates_natural_center(alpha,beta,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO)])[0] > epsilon):
                
            
                #The distance between 'S_k' final DMA expansion site and the overlap center P_{alpha,beta}
                #should always be > 0 here as 'weight_redistribution_multipoles()' function is called
                #within the main function 'compute_DMA_multipole_moment_final_expansion_center_one_site()'
                #ONLY to redistribute multipole components from 'natural' overlap centers
                #that ARE NOT final expansion sites, to other (e.g. neighboring) final DMA expansion sites
                sum_inverse_distances_to_final_expansion_sites+=1/scipy.spatial.distance.pdist([tab_position_center_S_k,coordinates_natural_center(alpha,beta,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO)])[0]
        
        return (1/scipy.spatial.distance.pdist([tab_position_center_S,coordinates_natural_center(alpha,beta,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO)])[0])/sum_inverse_distances_to_final_expansion_sites    
    
    """
    Any other redistribution strategy of the multipole moments
    from the 'natural' overlap centers to the final sites
    (corresponding to another index of the variable 'redistribution_strategy')
    can be implemented here easily
    """
 
##############################################################################
    
###################################################################################################################

###################################################################################################################
#The results is in atomic units (e.Bohr ; 1 e.Borh \approx 2.54 Debye)
def computes_total_dipole_from_local_multipoles_DMA_sites(x_0,y_0,z_0,result_multipoles,positions_final_expansion_sites):
    
    coordinates_origin=[x_0,y_0,z_0]
    
    total_dipole_cartesian=np.zeros(3)
    
    for k in range(len(result_multipoles)):
    
        #Contribution of local MONOPOLES to the total dipole : 
        #sum_{k=final DMA expansion sites} (q_k *(x_k or y_k or z_k))
        for i in range(3):
            #Conversion of coordinates from Angstroms to Bohr
            total_dipole_cartesian[i]+=result_multipoles[k][0][0]*(1/conversion_bohr_angstrom)*(positions_final_expansion_sites[k][i]-coordinates_origin[i])
    
    #print('Total Dipole (cartesian) after contribution of local MONOPOLES')
    #print(total_dipole_cartesian)
    #print(' ')
    
    
    for k in range(len(result_multipoles)):

        #Contribution of local DIPOLES to the total dipole :
        
        #Conversion of (local) dipoles from spherical form to cartesian form
        #'result_multipoles[k][1]' = {(Q_(1,-1))_{R_k},(Q_(1,0))_{R_k},(Q_(1,1))_{R_k}}
        
        #constant_factor=math.sqrt(4*math.pi/3.)
        constant_factor=1
        
        d_y=constant_factor*result_multipoles[k][1][0]
        d_z=constant_factor*result_multipoles[k][1][1]
        d_x=constant_factor*result_multipoles[k][1][2]
        
        local_dipoles_cartesian=[d_x,d_y,d_z]
        
        for i in range(3):
            total_dipole_cartesian[i]+=local_dipoles_cartesian[i]
    
    #print('Total Dipole (cartesian) after contribution of local DIPOLES')
    #print(total_dipole_cartesian)
    #print(' ')     
       
    #Result in atomic units (e*Bohr)
    return total_dipole_cartesian            
###################################################################################################################            

#############################################################################################
#Computes the total quadrupolar tensor (in cartesian coordinates) with respect to 
#the point (x_0,y_0,z_0), from the DISTRIBUTED local multipole moments 
#(not the multipole moments with respect to 'natural' overlap centers, but rather the multipole moments
#already redistributed at the final DMA expansion sites chosen [e.g. all atoms])
#Rq : for a neutral, non polar molecule (i.e. with zero total dipole : e.g. benzene), the
#total quadrupolar moment should not depend on the point (x_0,y_0,z_0), with respect to which
#the total quadrupole moment is computed
#Components of 'positions_final_expansion_sites' provided in Angstroms ==> conversion needed in Bohrs
#Implements the formula n°(...) in ....pdf
#'result_multipoles' : list of distributed multipole moments given in atomic units (e*Borh^k for multipoles of order k)
def computes_total_quadrupole_from_local_multipoles_DMA_sites(x_0,y_0,z_0,result_multipoles,positions_final_expansion_sites):
    
    coordinates_origin=[x_0,y_0,z_0]
    
    total_quadrupolar_tensor_cartesian=np.zeros([3,3])
    
    for k in range(len(result_multipoles)):
    
        #Contribution of local MONOPOLES to the total quadrupole :
        for i in range(3):
            for j in range(i,3):
                #Conversion of atomic coordinates components from Angstroms to Bohrs :
                total_quadrupolar_tensor_cartesian[i][j]+=result_multipoles[k][0][0]* (1/conversion_bohr_angstrom)**2 * (positions_final_expansion_sites[k][i]-coordinates_origin[i])*(positions_final_expansion_sites[k][j]-coordinates_origin[j])
    
    #print('Total quadrupolar tensor after contribution of local MONOPOLES')
    #print(total_quadrupolar_tensor_cartesian)
    #print(' ')
    
    for k in range(len(result_multipoles)):

        #Contribution of local DIPOLES to the total quadrupole :
        
        #Conversion of (local) dipoles from spherical form to cartesian form
        #'result_multipoles[k][1]' = {(Q_(1,-1))_{R_k},(Q_(1,0))_{R_k},(Q_(1,1))_{R_k}}
        
        #constant_factor=math.sqrt(4*math.pi/3.)
        constant_factor=1
        
        d_y=constant_factor*result_multipoles[k][1][0]
        d_z=constant_factor*result_multipoles[k][1][1]
        d_x=constant_factor*result_multipoles[k][1][2]
        
        local_dipoles_cartesian=[d_x,d_y,d_z]
        
        for i in range(3):
            for j in range(i,3):
                #Conversion of atomic coordinates components from Angstroms to Bohrs
                total_quadrupolar_tensor_cartesian[i][j]+=(local_dipoles_cartesian[i]*(positions_final_expansion_sites[k][j]-coordinates_origin[j])+local_dipoles_cartesian[j]*(positions_final_expansion_sites[k][i]-coordinates_origin[i]))*(1/conversion_bohr_angstrom)
    
    #print('Total quadrupolar tensor after contribution of  local DIPOLES ')
    #print(total_quadrupolar_tensor_cartesian)
    #print(' ')
    
    for k in range(len(result_multipoles)):

        #Contribution of local QUADRUPOLES to the total quadrupole :
        #'result_multipoles[k][2]' = {(Q_(2,-2))_{R_k},(Q_(2,-1))_{R_k},(Q_(2,0))_{R_k},(Q_(2,1))_{R_k},(Q_(2,2))_{R_k}}
        
        local_quadrupoles_cartesian=conversion_quadrupole_tensor_spherical_to_cartesian(result_multipoles[k][2])
        
        for i in range(3):
            for j in range(i,3):
                #Local quadrupoles are already in atomic units (e**Bohrs^k)
                total_quadrupolar_tensor_cartesian[i][j]+=local_quadrupoles_cartesian[i][j]
    
    #print('Total quadrupolar tensor after contribution of  local QUADRUPOLES ')
    #print(total_quadrupolar_tensor_cartesian)
    #print(' ')
    
    #####################
    #Symmetry of the total 3x3 cartesian quadrupolar tensor
    for i in range(3):
        for j in range(0,i):
            total_quadrupolar_tensor_cartesian[i][j]=total_quadrupolar_tensor_cartesian[j][i]
    
    #Result in atomic units (e*Borh^2)
    return total_quadrupolar_tensor_cartesian
#############################################################################################
    

#############################################################################################
#Same redistribution formula as  implemented in 'compute_DMA_multipole_moment_final_expansion_center_one_site()'
#but for only a single expansion site [x_0,y_0,z_0] (e.g. the origin)
#(one-center multipolar expansion)
#Computes the total quadrupolar tensor IN ATOMIC UNITS
def computes_total_quadrupole_spherical_from_local_multipoles_overlap_centers(x_0,y_0,z_0,multipole_moments_natural_centers,density_matrix_coefficient_pGTOs,total_nb_primitive_GTOs,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO):
    
    ##HERE ONLY ONE center "S" treated 
    total_quadrupole_moment_from_multipoles_overlap_centers=np.zeros(5)
    
    for m in range(-2,3):
        
        ###############################################
        #We count first the quadrupole moments already centered at point [x_0,y_0,z_0] i.e. \vec{P}_{alpha,alpha} or \vec{P}_{alpha,beta} = [x_0,y_0,z_0]
        for alpha in range(total_nb_primitive_GTOs):
        
            if (scipy.spatial.distance.pdist([coordinates_natural_center(alpha,alpha,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO),[x_0,y_0,z_0]])[0]< epsilon):  

                if (l_max(alpha,alpha,angular_momentum_numbers_primitive_GTOs)>=2):
            
                    total_quadrupole_moment_from_multipoles_overlap_centers[m+2]+=density_matrix_coefficient_pGTOs[alpha][alpha]*multipole_moments_natural_centers[alpha][0][2][m+2]
                
        for beta in range(alpha+1,total_nb_primitive_GTOs):
            
            if (scipy.spatial.distance.pdist([coordinates_natural_center(alpha,beta,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO),[x_0,y_0,z_0]])[0]< epsilon):  
                
                if (l_max(alpha,beta,angular_momentum_numbers_primitive_GTOs)>=2):

                    total_quadrupole_moment_from_multipoles_overlap_centers[m+2]+=density_matrix_coefficient_pGTOs[alpha][beta]*multipole_moments_natural_centers[alpha][beta-alpha][2][m+2]
                    
                    
        ###############################################          
                    
        ##################################################################################################
        ###############################################
        #We then count the quadrupole moments NOT already centered at point [x_0,y_0,z_0] 
        #i.e. \vec{P}_{alpha,alpha} or \vec{P}_{alpha,beta} \diff [x_0,y_0,z_0]
        #(which should be the case for most multipole moments)
          
                
        for alpha_1 in range(total_nb_primitive_GTOs):
            
        
            for beta_1 in range(alpha_1,total_nb_primitive_GTOs):
                
           
                if (scipy.spatial.distance.pdist([coordinates_natural_center(alpha_1,beta_1,basis_set_exponents_primitive_GTOs,position_nuclei_associated_basis_function_pGTO),[x_0,y_0,z_0]])[0] > epsilon):  
                    
                    
                    #Whatever the distance of the corresponding 'natural' overlap center \vec{P}_{alpha_1,beta_1}
                    #to the point of the SINGLE-point multipolar expansion (computation of the TOTAL quadrupolar moments)
                    #=> we redistribute its contribution to [x_0,y_0,z_0] ==> redistribution weight =1
                    #(weight_redistrib=1)
                            
                    #########################################################       
                    redistributed_multipoles=0
                            
                    if (m>0):
                                
                        real_part_1=real_part_redistributed_complex_multipoles(2,-m,alpha_1,beta_1,x_0,y_0,z_0,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
                        
                        real_part_2=real_part_redistributed_complex_multipoles(2,m,alpha_1,beta_1,x_0,y_0,z_0,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
        
                        redistributed_multipoles+=(real_part_1+((-1)**m)*real_part_2)/math.sqrt(2)
                               
                                
                    elif (m<0):
                                
                        imaginary_part_1=imaginary_part_redistributed_complex_multipoles(2,abs(m),alpha_1,beta_1,x_0,y_0,z_0,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
                                
                        imaginary_part_2=imaginary_part_redistributed_complex_multipoles(2,-abs(m),alpha_1,beta_1,x_0,y_0,z_0,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
                                
                        redistributed_multipoles+=(((-1)**m)*imaginary_part_1-imaginary_part_2)/math.sqrt(2)
                            
                                 
                    elif (m==0):
                                    
                        ##ATTENTION au signe ?? Cf. dipôle local sur le 'N' de NH3
                        redistributed_multipoles+= (-1)**2 * real_part_redistributed_complex_multipoles(2,0,alpha_1,beta_1,x_0,y_0,z_0,basis_set_exponents_primitive_GTOs,angular_momentum_numbers_primitive_GTOs,atomic_coordinates,position_nuclei_associated_basis_function_pGTO,density_matrix_coefficient_pGTOs,multipole_moments_natural_centers)
                            
                    #########################################################
                           
                    ################################
                    total_quadrupole_moment_from_multipoles_overlap_centers[m+2]+=((-1)**(2+m))*redistributed_multipoles
                    #############################
          
                    #print('total_quadrupole_moment_from_multipoles_overlap_centers['+str(m)+']')
                    #print(total_quadrupole_moment_from_multipoles_overlap_centers[m+2])
         
        #Electronic charge (in units of -e so far)
        total_quadrupole_moment_from_multipoles_overlap_centers[m+2]=-total_quadrupole_moment_from_multipoles_overlap_centers[m+2]
        
    return total_quadrupole_moment_from_multipoles_overlap_centers                
#############################################################################################    


